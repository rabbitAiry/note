# Head First设计模式

[TOC]

### #0 设计原则

1. 找出应用中可变之处并独立出来，不要和不需要变化的代码混在一起（改变的地方应该封装起来）
2. 针对接口编程，而不是针对实现编程
3. 多用组合（has-a），少用继承（is-a）
4. 为了交互对象之间的松耦合而努力
5. 类应该对扩展开放，对修改关闭（开闭原则）
6. 要依赖抽象，不要依赖具体类（依赖倒置原则）
7. 减少对象之间的交互（最少原则）



### #1 入门/策略模式

- 策略模式：定义了算法簇，分别封装起来，并让他们可以互相替换

- 示例1：黑头鸭，绿头鸭以及玩具鸭

  - 将方法`鸭叫`独立出来，依据不同叫声分为不同的类，因为鸭叫是鸭类中可变的。这些类皆继承自相同的`鸭叫`接口
  - 鸭子类（抽象父类）内部有一个该接口的成员变量引用。其鸭叫方法中，调用鸭叫实例的方法
  - 不同的鸭子在初始化时，将引用指向对应鸭叫类的实例
  - 见`项目ducks`
  
  

[TOC]

### #2 观察者模式

- 观察者模式：主题与观察者（Subject & Observer），可以看作出版者+订阅者
  - 按钮的添加点击事件就是观察者模式（addOnCLickListener）
- 自己动手的观察者模式：（探究原理）
  - 作为Subject接口：提供注册、删除和通知方法
  - 作为Observer接口：提供更新方法
  - 作为Subject类
    - 将所有通过接口注册的Observer使用ArrayList来管理
    - 通知方法中，调用所有observer的更新方法。当从气象站中获得更新时，调用该方法
  - 作为Observer类：
    - 构造器中获取Subject对应实例，并注册
    - 重写更新方法
- Java内置的观察者模式（Observable&Observer）
  - Subject改称Observable，且是一个类
  - 注册方法名: addObserver
  - 每次通知之前都应该先调用setChanged()方法。setChanged()方法会告知Observable其数据已发生改变。notifyObservers()方法只有发现数据确实发生了变化时才会执行通知操作
  - 见：`WeatherData`、`TwoListener`
- Java内置的观察者模式已被不推荐使用
  - 观察者被通知的顺序极易被改变，被通知顺序是不可被依赖的
  - Observable是一个类而不是一个接口，使得使用它的类不得继承其他超类，限制了其复用能力
  - Observable将关键方法setChanged()保护起来（protected），这不符合”多用组合，少用继承“的设计原则
- 松耦合：两个对象之间松耦合，可以交互，但是不太清楚彼此的细节。观察者模式是两个对象间的松耦合
  - 松耦合的设计使得OO系统变得弹性



[TOC]

### #3 装饰者模式：加入责任

- 开放-关闭原则：将注意力集中到设计中最有可能改变的地方，然后应用开闭原则
- 装饰者模式
  - 装饰者和被装饰者有相同的超类型，可以用一个或多个装饰者包装一个对象
  - 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的
- 示例3：咖啡店咖啡计价以及配料选择。此时顾客选择了一杯添加摩卡和奶泡的黑咖啡
  - 使用摩卡对象装饰黑咖啡，再用奶泡对象装饰摩卡黑咖啡对象。调用最外层装饰者的计价方法cost()不断计算得出价格
  - 这里使用继承，是因为可以强调加上配料后的咖啡仍是饮料的正确类型
- java中的装饰者模式：java.io类
  - InputStream是他们的抽象组件。FilterInputStream是抽象装饰者



[TOC]

### #4 工厂模式

- 示例4：pizza店

  ```java
  // 这是一个可变之处与不变之处混合在一起的代码
  
  Pizza orderPizza(String type){
      Pizza pizza;
   // 可变之处是pizza的种类
      if(type.equals("cheese")){
          pizza = new CheesePizza();
      }else if(type.equals("greek")){
          pizza = new GreekPizza();
      }else if(type.equals("pepperoni")){
          pizza = new PepperoniPizza();
      }else if(type.equals("veggie")){
          pizza = new VeggiePizza();
      }
  		
  // 不变之处是pizza的做法
      pizza.prepare();
      pizza.bake();
      pizza.cut();
      pizza.box();
      return pizza;
  }
  ```

  - 可变之处使用`工厂factory`来处理（放到一个类中）
  
- 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

- 抽象工厂模式：客户将从具体的产品、工厂被解耦，只与他们的抽象类相联系

- 依赖倒置原则：低层组件依赖高层组件




[TOC]

### #5 单例模式

- 单例模式：确保一个类只有一个实例，并提供一个全局访问点。（适用于多实例时，会导致程序行为异常、资源使用过量的情况）

  - Java1.2-版本的单例必须标为static，否则会被回收

  ```java
  // 初始的 单例模式代码
  public class Singleton {
      private static Singleton uniqueInstance;
      private Singleton(){}
  
      public static Singleton getInstance() {
          if(uniqueInstance == null){
              uniqueInstance = new Singleton();
          }
          return uniqueInstance;
      }
  }
  ```

- 这样的代码看似符合要求但是不能阻止多线程中无意间创建了两个实例的情况

  - 应该将getInstance()方法设置为同步`synchronized`，不让两个线程同时进入这个方法。但这会带来效率下降的问题，因为只有实例为创建时才需要同步。以下是三种做法

    - 忽略效率下降的事实
    - （“急切”创建实例）直接在声明时就实例化，每次被调用`getInstance()`方法就直接返回该实例
    - 双重检查加锁（Java1.4+）。只有实例未创建时，才会同步

    ```java
    public class Singleton {
        private volatile static Singleton uniqueInstance;
        private Singleton(){}
    
        public static Singleton getInstance() {
            if(uniqueInstance == null){
                synchronized(Singleton.class){
                  	// 再检查一次
                    if(uniqueInstance == null){
                        uniqueInstance = new Singleton();
                    }
                }
            }
            return uniqueInstance;
        }
    }
    ```




[TOC]

### #6 命令模式：封装请求

- 命令模式：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作



### #7 适配器：转换 与 外观模式

- 适配器：A转换得看起来像B（TurkeyAdapter(turkey)≈duck）
- 适配器模式：将一个类得接口，转换成客户期望得另一个接口。适配器让原本接口不兼容得类可以合作无间
- 两种适配器
  - 类适配器：继承自Target和Adaptee。在java中不能做到
  - 对象适配器：实现Target的接口，但是会委托给Adaptee（使用组合）
- 外观模式：外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更易用（外观与很多子系统达成Has-a关系）
- 



[TOC]

### #8 模板方法模式

- 



[TOC]

### #9 迭代器与组合模式



[TOC]

### #10 状态模式





[TOC]

### #11 代理模式





[TOC]

### #12 复合模式





[TOC]

### #13 与设计模式相处





[TOC]

### #14 剩下的模式