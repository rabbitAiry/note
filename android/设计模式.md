# Head First设计模式

[TOC]

### #0 设计原则

1. 找出应用中可变之处并独立出来，不要和不需要变化的代码混在一起（改变的地方应该封装起来）
2. 针对接口编程，而不是针对实现编程
3. 多用组合（has-a），少用继承（is-a）
4. 为了交互对象之间的松耦合而努力
5. 类应该对扩展开放，对修改关闭（开闭原则）
6. 要依赖抽象，不要依赖具体类（依赖倒置原则）
7. 减少对象之间的交互（最少原则）
7. 子类不要调用父类，而是父类调用子类（好莱坞原则）
7. 一个类应该只有一个引起变化的原因（一个类一个责任）（单一责任）



### #1 入门/策略模式

- 策略模式：定义了算法簇，分别封装起来，并让他们可以互相替换

- 示例1：黑头鸭，绿头鸭以及玩具鸭

  - 将方法`鸭叫`独立出来，依据不同叫声分为不同的类，因为鸭叫是鸭类中可变的。这些类皆继承自相同的`鸭叫`接口
  - 鸭子类（抽象父类）内部有一个该接口的成员变量引用。其鸭叫方法中，调用鸭叫实例的方法
  - 不同的鸭子在初始化时，将引用指向对应鸭叫类的实例
  - 见`项目ducks`
  
  

[TOC]

### #2 观察者模式

- 观察者模式：主题与观察者（Subject & Observer），可以看作出版者+订阅者
  - 按钮的添加点击事件就是观察者模式（addOnCLickListener）
- 自己动手的观察者模式：（探究原理）
  - 作为Subject接口：提供注册、删除和通知方法
  - 作为Observer接口：提供更新方法
  - 作为Subject类
    - 将所有通过接口注册的Observer使用ArrayList来管理
    - 通知方法中，调用所有observer的更新方法。当从气象站中获得更新时，调用该方法
  - 作为Observer类：
    - 构造器中获取Subject对应实例，并注册
    - 重写更新方法
- Java内置的观察者模式（Observable&Observer）
  - Subject改称Observable，且是一个类
  - 注册方法名: addObserver
  - 每次通知之前都应该先调用setChanged()方法。setChanged()方法会告知Observable其数据已发生改变。notifyObservers()方法只有发现数据确实发生了变化时才会执行通知操作
  - 见：`WeatherData`、`TwoListener`
- Java内置的观察者模式已被不推荐使用
  - 观察者被通知的顺序极易被改变，被通知顺序是不可被依赖的
  - Observable是一个类而不是一个接口，使得使用它的类不得继承其他超类，限制了其复用能力
  - Observable将关键方法setChanged()保护起来（protected），这不符合”多用组合，少用继承“的设计原则
- 松耦合：两个对象之间松耦合，可以交互，但是不太清楚彼此的细节。观察者模式是两个对象间的松耦合
  - 松耦合的设计使得OO系统变得弹性



[TOC]

### #3 装饰者模式：加入责任

- 开放-关闭原则：将注意力集中到设计中最有可能改变的地方，然后应用开闭原则
- 装饰者模式
  - 装饰者和被装饰者有相同的超类型，可以用一个或多个装饰者包装一个对象
  - 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的
- 示例3：咖啡店咖啡计价以及配料选择。此时顾客选择了一杯添加摩卡和奶泡的黑咖啡
  - 使用摩卡对象装饰黑咖啡，再用奶泡对象装饰摩卡黑咖啡对象。调用最外层装饰者的计价方法cost()不断计算得出价格
  - 这里使用继承，是因为可以强调加上配料后的咖啡仍是饮料的正确类型
- java中的装饰者模式：java.io类
  - InputStream是他们的抽象组件。FilterInputStream是抽象装饰者



[TOC]

### #4 工厂模式

- 示例4：pizza店

  ```java
  // 这是一个可变之处与不变之处混合在一起的代码
  
  Pizza orderPizza(String type){
      Pizza pizza;
   // 可变之处是pizza的种类
      if(type.equals("cheese")){
          pizza = new CheesePizza();
      }else if(type.equals("greek")){
          pizza = new GreekPizza();
      }else if(type.equals("pepperoni")){
          pizza = new PepperoniPizza();
      }else if(type.equals("veggie")){
          pizza = new VeggiePizza();
      }
  		
  // 不变之处是pizza的做法
      pizza.prepare();
      pizza.bake();
      pizza.cut();
      pizza.box();
      return pizza;
  }
  ```

  - 可变之处使用`工厂factory`来处理（放到一个类中）
  
- 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

- 抽象工厂模式：客户将从具体的产品、工厂被解耦，只与他们的抽象类相联系

- 依赖倒置原则：低层组件依赖高层组件




[TOC]

### #5 单例模式

- 单例模式：确保一个类只有一个实例，并提供一个全局访问点。（适用于多实例时，会导致程序行为异常、资源使用过量的情况）

  - Java1.2-版本的单例必须标为static，否则会被回收

  ```java
  // 初始的 单例模式代码
  public class Singleton {
      private static Singleton uniqueInstance;
      private Singleton(){}
  
      public static Singleton getInstance() {
          if(uniqueInstance == null){
              uniqueInstance = new Singleton();
          }
          return uniqueInstance;
      }
  }
  ```

- 这样的代码看似符合要求但是不能阻止多线程中无意间创建了两个实例的情况

  - 应该将getInstance()方法设置为同步`synchronized`，不让两个线程同时进入这个方法。但这会带来效率下降的问题，因为只有实例为创建时才需要同步。以下是三种做法

    - 忽略效率下降的事实
    - （“急切”创建实例）直接在声明时就实例化，每次被调用`getInstance()`方法就直接返回该实例
    - 双重检查加锁（Java1.4+）。只有实例未创建时，才会同步

    ```java
    public class Singleton {
        private volatile static Singleton uniqueInstance;
        private Singleton(){}
    
        public static Singleton getInstance() {
            if(uniqueInstance == null){
                synchronized(Singleton.class){
                  	// 再检查一次
                    if(uniqueInstance == null){
                        uniqueInstance = new Singleton();
                    }
                }
            }
            return uniqueInstance;
        }
    }
    ```




[TOC]

### #6 命令模式：封装请求

- 命令模式：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作



### #7 适配器：转换 与 外观模式

- 适配器：A转换得看起来像B（TurkeyAdapter(turkey)≈duck）
- 适配器模式：将一个类得接口，转换成客户期望得另一个接口。适配器让原本接口不兼容得类可以合作无间
- 两种适配器
  - 类适配器：继承自Target和Adaptee。在java中不能做到
  - 对象适配器：实现Target的接口，但是会委托给Adaptee（使用组合）
- 外观模式：外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更易用（外观与很多子系统达成Has-a关系）



[TOC]

### #8 模板方法模式：操作中有重复之处的类

> 痛点：咖啡和茶是一样的煮法，不应该分开写

- 模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤
- 模板中使用钩子(hook)：存在于执行的操作中，子类可以选择是否要覆盖（操作中的可选部分）（模板中不添加abstract关键词）
- 例子：Array类的sort方法



### #9 迭代器与组合模式

> 痛点：被合并的两个菜单采用了不同的组合数据类型，难以一并遍历

- 迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示
- 迭代器接口适用于抽象了集合(collection)的遍历，一共有三个方法`hasNext()`和`next()`、`remove()`，适合用while循环遍历
- java提供了Iterator接口，ArrayList也提供了返回迭代器的方法

> 痛点：设置子菜单（比如选择青菜面中可以选择粉和面）时无法被遍历

- 组合模式：允许将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合
- 组合模式下推荐使用递归，可以方便地实现功能
- 对于分支节点和叶子节点，同时继承自节点必然面临某些方法不可用的问题，在继承时可以为不适用的方法通过throw抛出表示不支持。组合模式并不符合“单一责任”的设计原则



### #10 状态模式

> 痛点：自动贩卖机有不同的状态：掉商品、售罄等。状态的增加将导致代码复杂

- 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
- 状态模式使用接口封装了多种状态，对象可以通过委托来改变状态。可以使用Context对象记录多组状态



[TOC]

### #11 代理模式

> 痛点：经理想要获取所有糖果机的状态

- 代理：代表某个真实的对象
- 代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问
- 远程代理：首先，客户端获取服务器的Proxy，服务器返回Proxy，然后客户端通过查询服务器以获取结果

> 痛点：从本地加载图片。加载完成前，代理只会返回空图片

- 虚拟代理：把创建开销大的对象当作服务器，在必要时连接该对象实现真正的方法（适合与状态模式一起用）

> 痛点：商家可以修改自己餐厅的菜单，但不能修改自己餐厅的评分，或者别人的菜单

- 保护代理（java提供的动态代理）：根据访问权限决定客户可否访问对象的代理:flags:
  - 创建两个InvocationHandler，一个给拥有者使用，另一个给非拥有者使用
  - 创建Proxy类并实例化Proxy对象
  - 利用适当的代理包装任何对象
- 更多代理
  - 防火墙代理
  - 智能引用代理
  - 缓存代理
  - 同步代理
  - 复杂隐藏代理
  - 写入时复制代理



### #12 复合模式

- 复合模式在一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题
- 复合模式MVC



[TOC]

### #13 与设计模式相处

- 模式是工具而非规定
- 更多模式
  - 架构模式
  - 应用模式：建立系统级架构的模式
  - 领域特定模式：关注特定领域问题
  - 业务流程模式：描述业务、顾客和数据之间的交互
  - 组织模式
  - 用户界面设计模式
  - ...



[TOC]

### #14 剩下的模式

- 桥接模式Bridge Pattern
- 生成器模式Builder Pattern
  - 封装一个产品的构造过程，并允许按步骤构造
- 责任链Chain of Responsibility Pattern
  - 链中的每个对象扮演处理器（Handler），如果它可以处理请求，则进行处理，否则把请求转发给下一个Handler
- 蝇量模式Flyweight Pattern
- 解释器Interpreter Pattern
- 中介者Mediator Pattern
  - 集中相关对象之间复杂的沟通和控制方式
- 备忘录Memento Pattern
  - 让对象返回之前的状态
- 原型Prototype Pattern
  - 适用于创建给定类的实例的过程很昂贵或很复杂时
- 访问者模式Visitor Pattern
  - 允许对组合结构加入新的操作而无需改变结构本身