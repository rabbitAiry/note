# 力扣刷题笔记

[TOC]

##### #1 两数之和

##### #2 两数相加



##### #3 无重复字符的最长子串

> 双指针-滑动窗口

- 思路
  1. 把左指针都看作起点，右指针不断往右查看不重复的字符串最多能够有多长。通过将字符加入HashSet验证是否有重复，最终返回最大值
  2. 左指针作为字符串的起点，右指针则不断验证新的字符是否能够被加入到字符串中。通过将字符加入Queue中进行管理，若发现有重复，即不断使元素出队，直到重复元素出队为止。此方法相当于把右指针看作终点，因为使用右指针探路不容易溢出，所以此方法比思路一更容易操作



##### #4 寻找两个有序数组的中位数

1.   合并数组
     -   形式上合并数组：创建新数组，再返回中间值
     -   思想上合并数组：显然可以直到中间值是第几个数，于是使用双指针即可
2.   使用二分查找排除中位数前的数
     -   令中位数为两者合并后的第k位数，既然不能直接排除前k位，则排除前k/2位
     -   通过比较，可以直到应该排除哪个数组中的前k/2位
     -   不断排除前k/2位，并不断更新k值（k的定义未变），直到k==1时，返回两个数组中第一小的值

-   思考
    -   二分查找就是通过缩小范围，但这题的二分查找并没有通过左右指针的方式，而是令k值不断除以二，直到其值为1



##### #5 最长回文子串

1. 利用回文串的特点，不断遍历字符串，并对字符串的每个字符向外扩展并判断是否为回文。
2. (1+)事实上左指针和右指针能够转换为当前最大长度和中间位置，使用并记录扩展步数更是多余的，所以可以将向外扩展分离为单独的函数。此外，虽然该算法只是从字符串每个字符向外扩展，但是每次扩展最多会扩展O(n)次，所以该算法的时间复杂度是O(n^2^)
3. 使用动态规划：从你可以保证的开始，逐步往外扩展，这是动态规划。能够知道的是长度为1的必为回文子串；若某个子串是回文子串，则其两端相等，且左右各缩一步也是回文子串。以长度为突破口，将结果记录在二维数组中，最终得出最长子串。时间复杂度是O(n^2^),但耗时提升大，空间复杂度也相比上一种方法更复杂，为 O(n^2^)



##### #6 Z字形变换

> 数组

- 思路
  1. 可以按照z字形顺序来访问字符串
  2. 也可以构建行数个StringBuffer，按照顺序访问字符串，并依次添加到对应的StringBuffer中



##### #7 整数翻转

> 数学

- 思路
  1. 这道题的重头戏在如何处理正负，以及如何判断溢出。值得一提的是，java中负数的除法、求余得到的都是负数，所以正负数的操作是一致的。判断上可以先判断当前值是否大于最大值除以10，再比较加上的数是否会大于最大值mod10
  2. 答案的方法，通过简单的不等式和讨论条件推导，使得判断条件变得格外简单。在设计计算的问题上，不妨也先这样试一下



##### #8 字符串转换整数

- 思路
  1. 按题目要求即可，但是特别多的细节需要注意。特别注意的是，当一个数为负数且需要比较其添加值是否溢出时，不能直接用最小值余10在前面加个负号，因为有无负号结果皆为负数



##### #9 回文数

- 思路
  1. 把数字转为String类型后，直接双指针从两端遍历
  2. 不转换为字符串，将原数字的一半数拿出来作为一个新的数字，最后比较这两个数是否相同或者等于新数字除以10



##### #10 正则表达式匹配



##### #11 盛最多水的容器

1. 暴力 超时
2. 暴力 优化
    -   `s = h*l`
    -   对外循环的i进行限制：若该数字比前一位小，则意味着h、l都减小了，不可能再次产生最大值，因此跳过。能通过但耗时较长
3. 双指针
    -   通过公式知道了面积由距离和两者高度最小值共同决定，但是高度最小值并不可控，所以从距离下手
    -   距离的最大值为数组的长度len-1，所以应该从两头开始向中间遍历这个数组
    -   想到最佳的答案一定会是两个边界数值都相对较大，所以在遍历过程中，每次只让矩形长度减一，放弃左右指针中的最小值
    -   复杂度为O(n)



##### #12 整数转罗马数字

- 思路
  1. 罗列出所有可能性，叠加



##### #13 罗马数字转整数

- 思路
  1. 通过判断下一个char所代表的数字比当前char代表数字要大来判定：当前是一个字母代表一个数字还是两个字母（如：IV）代表一个数字



##### #15 三数之和

```
双指针
```

- 思路
  1. 暴力三循环：为了保证题目的【没有重复元素】，所以选择数组的排序为起点，排序后在循环过程中查重。但是这个时间复杂度为O(n^3^)的算法超时了
  2. 一重循环加双指针：事实上并非循环就一定能够得到结果。由于已经排过序了，可见第二个元素向右递增且第三个元素向右递增时，三者之和只会越来越大；只有第三个元素向左递减时才有可能让结果维持为0。因为找到了两个元素之间的联系，所以可以用得上双指针：当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2^)减少至 O(N)。再加上第一重循环，所以时间复杂度为O(N^2^)
- 提示
  1.  有顺序的数组可以使用双指针节省循环时间




##### #16 最接近的三数之和

> 双指针

- 思路
  1. 与15类似。但是有一点要注意，最大值尽量不要直接写Integer.MAX_VALUE，而是依据题目设定，尤其是出现最大值减去一个负数的时候



##### #17 电话号码的字母组合

> 枚举、回溯（dfs）

- 思路
  1. 直接枚举即可，要注意安排顺序



##### #18 四数之和

> 双指针

- 思路
  1. 同三数之和。但是从前面的循环开始设置剪枝可以提高速度。不需要怕麻烦，因为剪枝处越接近起点，带来的性能提升很大



##### #19 删除链表的倒数第N个节点

> 双指针

- 思路
  1. 快慢指针，慢指针比快指针晚N+1步出发
  2. （优化）为头节点之前添加一个伪节点，这样可以方便处理头节点被删除的情况



##### #20 有效的括号



##### #22 括号生成

1.   回溯
     -   符合条件的字符串，需要保证右括号不会大于左括号的数量，左括号不会大于括号数量。基于此条件进行递归



##### #23 合并k个排序链表

1.   暴力
     -   时间复杂度为O(kn)，n为所有节点数量
2.   暴力-优化
     -   在【合并2个排序链表】中，并不是所有的节点都会比较一次，假若任意链表已经为空，则可以直接替换。
     -   因此令所有链表不断与答案链表合并，最后生成唯一的链表，可以优化速度（时间上比纯暴力快了一半）
     -   时间复杂度为O(kn)
3.   暴力-使用分治合并优化
     -   两两链表合并，最终归一
     -   尽管合并次数相同，但是由于每层的合并操作中，链表节点数量并不是相等的，随着链表数量的减少，链表节点数量增加，从而优化了速度
     -   仅在此思路中令n为链表最长的节点数量，时间复杂度为O($\sum_{i=1}^\infin\frac{k}{2^i}\times2^in$) = O(kn×logk)，与思路四是同等时间复杂度的。而由于需要使用递归，因此空间复杂度为O(logk)
4.   使用优先队列
     -   k是可以优化的，因为每次获取第n个数时都需要从k个链表头中查找，然后需要找到其中val最小的，并更改某一个链表头指向下一位。因此想到使用优先队列来维护这k个链表头
     -   删除和插入的时间复杂度为O(logk)，故时间复杂度为O(n×logk)，空间复杂度为O(k)

-   思考
    -   指向数组的引用同样是复制。所以要么直接对着数组操作，要么直接不依赖数组获取值



##### #24 两两交换链表中的节点



##### #25 k个一组翻转链表

1.   链表
     -   其实这题思路并不难，难在细节上。只需要记得当前需要做什么就好

-   思考
    -   字节的面试对这题要求是20分钟内能够完成



##### #28 实现strStr()

1.   暴力 
2.   KMP算法





##### #33 搜索旋转排序数组

1. 暴力。此题耗时不长
2. 半二分查找
    -   先找到数组真正的起点，然后判断target应该位于哪一个区间
    -   在对应区间中使用二分查找
3. 二分查找 优化
    -   在数组中随机找一个位置，这个位置的左右侧总有一方是有序的，因此，总是可以判断target位于哪一个区间，所以直接使用二分查找



##### #34 在排列数组中查找元素的第一个和最后一个位置

> 二分查找

- 思路
  1. 我的做法是通过二分查找找到target，然后从该位置扩散找到起始位和终点位。时间复杂度为O(logN+m)，m是值为target的数量
  2. 答案做法是分别使用二分查找找到起始位和终点。



##### #35 搜索插入位置

> 双指针-二分查找

- 思路
  1. 因为数组元素有序，所以使用二分查找



##### #36 有效的数独



##### #39 组合总和

1.   回溯
     -   为了保证组合结果不重复，则货币的使用必须按照一定的顺序。首先准备了一个空列表，并尝试往列表中添加元素
     -   每次回溯到节点时，可以选择添加当前元素或者不添加而切换到下一元素，这样保证了顺序
2.   动态规划
     -   该题与#322类似，只不过该题需要得到组合的内容，而#322只需要得到组合的数量。可以使用新的序列来记录



##### #40 组合总和Ⅱ

1.   回溯
     -   数组中有重复的元素，而数组中每个元素使用次数也只有一次，因此想到使用哈希表记录它们之间的关系
     -   在dfs过程中，因为使用次数不可控，所以直接进行了不同次数使用该元素的dfs
     -   为了方便使用哈希表，这里使用了`List<int[]>` 



##### #42 接雨水

>   贪心、动态规划

-   思路
    1.  使用贪心算法（暴力）。记录下遍历过程中的最大值，当遍历过程中出现前一位比当前位小时，统计能够装多少水
    2.  使用动态规划。对于下标i，下雨后能到达的最大高度取决于其左右两侧的最大高度的最小值。于是使用两个数组以存储左侧最大高度和右侧最大高度，然后遍历得到当前位置的高度最小值并统计起来。此算法使得时间复杂度降为O(n)
    3.  使用双指针优化动态规划。注意到下标i处能接的雨水由左侧最大高度数组和右侧最大高度数组决定，因此可以使用双指针和两个变量代替
-   提示
    -   动态规划的出发点是从某个下标开始的，而不是绝对的从头开始



##### #43 字符串相乘



##### #45 跳跃游戏Ⅱ

1. 动态规划
    -   遍历数组，使用新的数组用以记录到达该位置的最小值，在遍历过程中把能够到达的index填入步数，直到找到最后一位。
2. 贪心
    -   上述思路混淆了“可以跳跃”和“跳跃至”的概念。可以跳跃意味着选择更多，可以跳跃得越远绝对是越好的。
    -   通过观察思路1的dp数组，可以发现随着遍历元素越多，步数总是会随之不断增加或不变
    -   使用变量max不断维护该位置及之前最远能够到达的位置，使用变量currMax记录当前步数下，所能够到达的最远位置。只有当前位置等于currMax时，才需要更新该值



##### #46 全排列

- 提示
  - 全排列的交换应该包括自己与自己交换
  - 可以将数组转换成list来操作，以方便结果的添加；以及可以使用`Collections.swap()`方法来交换元素位置



##### #47 全排列Ⅱ

1.   全排列 哈希表
1.   全排列 添加前排重
     -   与曾经熟悉的#46全排列算法不同，通过添加数组元素到列表的方式去理解排列行为，并使用boolean数组记录是否已使用，这种做法更清楚地排除重复元素



##### #48 旋转图像

>   数组

-   思路
    1.  想要通过`.clone()`方法来克隆数组，但是因为是二维数组，所以终究新数组的变动会导致旧数组的变动。应该对每个元素都遍历一遍的方式来复制
    2.  旋转可以看作是四个小长方形的旋转，因此只需遍历其中一个小长方形并对小长方形内的每个元素都进行一次旋转即可
    3.  数组可以先经过水平轴翻转，然后再经过主对角线翻转以获得结果



##### #49 字母的异位词分组

1.   排序
     -   对每个字符串拆成char数组后排序，然后重新生成字符串并加入哈希表中

-   注意
    -   字符串数组的哈希值会随位置变化，但Java字符串不会。所以添加字符串时
        -   不可以写`ca.toString()`
        -   应该写`new String(ca)`



##### #53 最大子序和

> 动态规划



##### #55 跳跃游戏

> 贪心

- 思路
  1. 从最后一位向前推测所能到达的位置是否包含0。该思路混淆了“可以跳跃”和“跳跃至”的概念。未尝试
  2. 从第一位开始遍历数组，不断探索每一个下标其能够到达的最远位置。若当前下标已经不可到达，则跳过该下标。时间复杂度优化为O(n)



##### #56 合并区间:star:

> 数组

- 思路
  1. 使用排序将区间解决了分组的问题。只要当前区间的左边界大于答案区间的右边界，即需要创建新分组。
- 提示
  - 要做的是解决问题，而不是考虑通用性
  - 如果不能够一眼望近地解决问题，则应该考虑使用线性方式，按顺序来解决问题。使用排序，使得看待问题的角度发生变化
  - 先解决了答案区间何时创建的问题，再解决答案区间内容的问题



##### #59 螺旋矩阵Ⅱ



##### #62 不同路径

1.   动态规划：这是二维的#70爬楼梯
2.   组合数学：这也是组合的基础题，向右n-1步，向下有m-1步，得到$C_{m+n-2}^{m-1}$，使用循环计算得到结果

-   提示

    -   组合公式

        $A^m_n = \frac{n!}{(n-m)!}$ 

        $C^m_n=\frac{A^m_n}{m!}=\frac{n!}{m!(n-m)!}$ 



##### #63 不同路径Ⅱ

##### #64 最小路径和

##### #66 加一



##### #70 爬楼梯

> 动态规划

- 思路
  1. 用 f(x)f(x)f(x) 表示爬到第 xxx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：`f(x)=f(x−1)+f(x−2)` 
- 提示
  - 从题目中看出这条动态规划转移方程并不容易。原来的思路是依据爬楼梯过程中出现2的次数分组，然后再计算2的位置排列组合方式来计算答案，但是由于出现重复的情况无法排除，故不能完成题目



##### #72 编辑距离:star:

1.   动态规划

     -   题目提到了三种基本操作：插入、删除、替换，且它们的编辑步数皆为1。因为在A中执行删除和在B中执行插入的是等价的，所以将原来的操作转换为：在A中插入、在B中插入、在A中修改
     -   以`A=horse`，`B=ros`作为例子，求A到B的编辑距离
         -   如果知道`horse`到`ro`的距离为a，则距离为不会超过a+1
         -   如果知道`hors`到`ros`的距离为b，则距离为不会超过b+1
         -   如果知道`hors`到`ro`的距离为c，则距离为不会超过c+1
         -   那么，A到B的编辑距离为`min(a+1,b+1,c+1)`
     -   以`A=空`，`B=ros`作为例子，显然编辑距离为B的长度3
     -   用D\[i][j]表示A的前i个字母和B的前j个字母，此时得到状态转移方程

     ```java
     // 最后一个字母相同
     D[i][j]=min(D[i][j]+1,D[i-1][j]+1,D[i-1][j-1])
     // 最后一个字母不同
     D[i][j]=min(D[i][j]+1,D[i-1][j]+1,D[i-1][j-1]+1)
     ```

-   提示
    -   动态规划需要：通过转移方式确认什么才算是一种状态，然后得到状态转移方程



##### #73 矩阵置零



##### #74 搜索二维矩阵

1.   二分查找
     -   先对行查找，再对列查找
2.   二分查找优化
     -   通过映射的方式，将矩阵看作是一个大的一维数组，然后使用二分查找

- 注意

  - 如果mid出现了指针不移位导致的死循环，可以如下处理

    `int mid = (left+right+1)/2; `



##### #75 颜色分类

> 排序

- 思路
  1. 直接使用`Arrays.sort()`
  2. 记录下所有数字出现次数，然后重新填充
  3. 因为题目数组只有3个数字，所以可以使用两个指针，将0移到前面，2移到后面



##### #77 组合

> 排列

- 提示

  - 添加新的数组队列应该如下

  ```java
  ans.add(new ArrayList<>(list));
  ```



##### #78 子集

1.   全排列+筛选

     -   若上一位的值比当前值小（或是第一位），则不对当前顺序进行dfs

2.   标准的子集写法

     ```java
     public void dfs(int cur, int[] nums) {
         if (cur == nums.length) {
             ans.add(new ArrayList<Integer>(t));
             System.out.println(t);
             return;
         }
         t.add(nums[cur]);
         dfs(cur + 1, nums);
         t.remove(t.size() - 1);
         dfs(cur + 1, nums);
     }
     ```

3.   枚举

     -   因为元素不重复，则子集数量必定是2^n^-1个，且发现可用其二进制形式表示第i位元素是否在队列中（000>0, 101>5, ... ,111>8）
     -   该方法需要了解二进制运算

     ```java
     for (int i = 0; i < n; ++i) {
         if ((mask & (1 << i)) != 0) {
             t.add(nums[i]);
         }
     }
     ```



##### #79 单词搜索




##### #82 删除排序链表中的重复元素Ⅱ

> 链表

- 思路
  1. 一次遍历。要注意判断是否为空节点
- 提示
  - 只要找到解题顺序，问题就能解



##### #83 删除排序链表中的重复元素



##### #88 合并两个有序数组

> 数组

- 思路
  1. 先合并后排序
  2. 因为数组nums1[]的后半部分为空，因此可以从后往前排序



##### #90 子集Ⅱ:star: 



##### #91 解码方法

1.  动态规划
    -   这是一道#77爬楼梯的增强版，在踏上这片楼梯之前，还需要先判断以下这片楼梯是否能够踏足。

-   思考
    -   仅求解可能方式的数量，要想到动态规划



##### #94 二叉树的中序遍历



##### #96 不同的二叉搜索树

1.  动态规划
    -   给定一个有序数列1..n，为了构建出一棵2二叉搜索树，可以遍历每个数字，并将该数字作为树根，将其左侧作为左子树，右侧作为右子树
    -   由于根的值不同，因此能保证每棵二叉搜索树是唯一的
    -   接着再按照同样的方法递归构造左子树和右子树。由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用，因此想到使用动态规划来求解本题
    -   定义G(n)为长度为n的序列能构造成的不同二叉搜索树的个数，F(i,n)是以i为根，序列长度为n的不同二叉搜索树的个数
    -   显然有如下式子：$G(n) = ∑_{i=1}^n(F(i,n))$ ，边界情况有`G(0)=1 G(1)=1`
    -   对于F(i,n)，则有如下公式`F(i,n) = G(i-1)*G(n-i)`
    -   因此只需要计算G(n)即可



##### #101 对称二叉树

> 树

- 思路
  1. bfs，对每一层进行一次对称检查。要注意不能漏掉值为null的节点，否则会产生伪对称的现象
  2. 通过同步移动两个指针来遍历这棵树：指针p右移时，q左移；指针p左移时，q右移，若两者值不相同则不对称



##### #103 二叉树的锯齿形层序遍历

1.   BFS
     -   与其最后翻转链表，不如每次添加时都添加到头部



##### #105 从前序与中序遍历序列构造二叉树:star: 

1.   递归
     -   试着把每次递归都看作是填充根节点

-   思路
    -   前序遍历：[root, [左树], [右树]]
    -   中序遍历：[[左树], root, [右树]]
    -   递归没做出来的原因：没能找到递归的理由



##### #108 将有序数组转换为二叉搜索树

1.   递归
     -   平衡的二叉搜索树有很多种形式，只需要符合平衡要求即可
     -   要做到平衡，只需确保树的左右端点节点总是一样多，使用二分查找可以解决这个问题



##### #110 平衡二叉树

1.   BFS 失败
     -   因为题目提到了平衡二叉树的定义是每颗子树的高度差绝对值都不能超过1，使用BFS不能体现出“每颗”
2.   DFS
     -   遍历树，并对每个节点都获取其左右节点的以检查其是否平衡，并获取左右子树是否平衡
     -   显然，求高度需要遍历树，求平衡也需要遍历树，使得时间复杂度较高
     -   时间复杂度为O(n^2^)，空间复杂度为O(n)
3.   DFS 后序遍历
     -   将平衡结果体现在返回的高度中，若不平衡，则返回-1
     -   时间复杂度为O(n)

-   思路
    -   明明只需一步就可以降低时间复杂度了，但是困惑于如何体现其不平衡。这里的做法是返回一个不正常的值



##### #112 路径总和



##### #113 克隆图

1.   DFS
     -   使用HashMap进行查重，若已经遍历过该节点，则返回节点对应的克隆节点，即map的value



##### #116 填充每个节点的下一个右侧节点

> 广度优先遍历

- 思路

  1. 写出算法即可

- 提示

  - 使用队列

  ```
  Queue<Node> queue = new LinkedList<Node>();
  ```

  - 获取下一个队列元素：peek()



##### #117 填充每个节点的下一个右侧节点指针 II

1. BFS
2. BFS优化
    -   既然每一层都可以通过next看作是链表，那么就可以不使用队列，而是通过链表的遍历来完成
    -   将已经形成了链表的层称为第i层，通过遍历第i层，为第i+1层以使用next的方式建立链表
    -   空间复杂度优化为O(1)

-   思考
    -   如果题目要求更改结构，则可以思考已经变更的结构是否能够为我所用



##### #118 杨辉三角

##### #119 杨辉三角Ⅱ

>   数组

-   思路

    1.  直接递推，使用二维数组记录整个三角。由于每一行只需要用到上一个数组，所以可以优化为只使用两个数组

    2.  优化为O(n)：递推式$C^i_n=C^i_{n-1}+C^{i-1}_{n-1}$表明，当前行第 i 项的计算只与上一行第i−1项及第i项有关。因此我们可以倒着计算当前行.

        



##### #120 三角形最小路径和

> 动态规划

- 思路
  1. `f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]`
  2. 使用该动态转移方程，对三角形底部最后一行的每一个元素查找一次最小值，并使用二维数组记录每一个位置的最小路径。由于路径值可能为0，所以需要使用额外的bool二维数组记录是否访问过。
  3. 上述过程可以进行优化。从每一层遍历得到最小路径结果并记录在二维数组中，从上到下遍历每一层，这样就不需要使用bool二维数组记录是否访问过该位置
  4. 空间复杂度优化至O(n)：仅使用一维数组，记录每上一行的数据



##### #121 买卖股票的最佳时机

##### #122 买卖股票的最佳时机Ⅱ



##### #130 被围绕的区域

1.   BFS 超时
     -   从边界入手标记O点，然后进行一次BFS，最后重新遍历一次表格，把未被标记的O点改为X
2.   BFS 优化
     -   从边界搜索时只将对应位置加入队列中，在最后遍历表格之前才进行BFS，这样只需要一次BFS即可



##### #136 只出现一次的数字

> 位运算

- 思路
  1. 通过异或运算找到唯一的数字`single^=i;`



##### #139 单词拆分

>   动态规划

-   思路
    1.  通过递归的方式，找到一个位置能够放一个单词后，接着找下一个。遗憾的是超时了
    2.  优化时间：将列表转哈希表，然后使用数组记录当前位置是否可到达，以减少思路1如同树形结构般，每次都要从头开始遍历。时间复杂度同样是O(n^2^)，但是更快速。写出动态规划转移方程：`dp[i]=dp[j] && check(s[j..i−1])`。
-   技巧
    -   尽管使用char[]比charAt()更快速，但是new String(Arrays.copyOfRange(ca))比string.substring()要慢很多



##### #141 环形链表

> 链表

- 思路
  1. 通过set来识别是否有重复的节点
  2. 通过快慢指针的运作是否会相遇来判断是否落入循环
  3. 通过改变链表的值以达到做标记的效果以区分是否落入循环
- 技巧
  - 没做出来的原因是不知道如何识别这是进入了循环



##### #142 环型列表Ⅱ

1.   哈希表
2.   快慢指针
     -   需通过数学证明



##### #143 重排链表

1.   数组
     -   将节点记录，然后重排

2.   链表综合
     -   两端链表混合穿插，也就是指针要时刻指向链表两端并往中间靠拢。对于右指针而言，在单链表中显然很难做到。再者，链表最终会在链表中间截止，因此中间往右开始的节点都需要被移动顺序
     -   得到了“中间”、“顺序”两个关键词，于是想到使用快慢指针指出右半部分节点范围，对其进行反转链表。这下就可以愉快地使用

-   思考
    -   方法一显然时间复杂度不高，但是没能够想到
    -   方法二实现了对链表的灵活操作，但是耗时近40分钟



##### #144 二叉树的前序遍历

##### #145 二叉树的后序遍历

##### #150 逆波兰表达式求值



##### #152 乘积的最大子数组

>   动态规划

-   思路
    1.  显然，数组中只有0和负数会干扰乘积的最大，若只有正数的话，只需一直相乘就找到最大值了。解题的思路是动态规划，不断遍历，把第i个元素作为最大子数组的结尾，若遇到第一个负数，则记录负数前的乘积为before，若遇到第偶数个负数，则所有一起相乘，若遇到第奇数个负数，则除以若遇到0，则当做重新开始。这个思路体现了动态规划的思想，f(i)是结尾包括i的子数组的最大值，但是完全依靠着常识得出的结论，于是代码逻辑写得较乱，思考时间较长，但是其空间复杂度仅为O(1)
    2.  $f_{max}(i) = max^{n}_{i=1}\left[f_{max}(i-1)*a_i, f_{min}(i-1)*a_i,a_i\right]$ ,$f_{min}(i) = min^{n}_{i=1}\left[f_{max}(i-1)*a_i, f_{min}(i-1)*a_i,a_i\right]$ 。上述是该题的动态规划方程，并不拘泥于知道数据中遇到了多少个负数，而是把正值最大和负值绝对值最大共同遍历维护从而得到结果，简化了计算过程。需要思考到，如果动态规划涉及到了状态有可能不断变更，则不如两种状态一起遍历



##### #153 寻找旋转数组中的最小值

> 二分查找

- 思路
  1. 不断遍历数组，直到数组中出现小于数组最后一位值得数字。时间复杂度为O(n)
  2. 使用二分查找
- 提示
  - 一开始想到使用双指针往中间，但是会出现因为数组元素数量为单双数时需要分类讨论，没成功。需要分类讨论的解决方法容易出错。
  - 有序数组的范围锁定一定要想到使用二分查找



##### #155 最小栈

1.   暴力
2.   利用栈的特性
     -   使用了额外的栈，其栈顶是原来的栈在不同操作后的最小值。时间复杂度优化为O(1)



##### #160 相交链表

1.   哈希表暴力
2.   双指针
     -   想方设法让两个指针相遇在第一个相交的节点
     -   令链表1的不相交节点数为a，链表2的不相交节点数为b，相交节点数为c
     -   假若a==b，则还没遍历完链表就能够捉刀相遇
     -   假若a!=b，则当任意指针走到终点，则从对方链表开始遍历。因为a+c+b == b+c+a，因此终究会相遇



##### #162 寻找峰值

-   思考
    -   在趋势图中也可以使用二分查找



##### #167 两数之和Ⅱ：有序数组

> 双指针

- 思路
  1. 因为数组有序，所以自然会考虑使用双指针。证明可以假设此时某一指针已经到达target解的一个位置，说明此时不可能再大/小了



##### #187 重复的DNA序列

1.   哈希表
     -   使用两个哈希表，一个是为了了解当前子字符串是否重复出现了，另一个是为了防止往答案列表重复添加



##### #189 旋转数组

> 数组、分析

- 思路

  1. 使用新的数组，直接求余拷贝

  2. 每次执行一次向右移动，执行n次。虽然容易理解，但性能不佳

  3. 环状替换：和方法1不同，只是暂时地保存被替换的元素到temp中。通过计算得知会有gcd(k,n)轮的循环，每轮循环中每个元素不断与后k位交换

  4. 基于以下事实：当数组元素向右移动n次后，尾部会有k mod n个元素移动至头部，其余元素则向后移动k mod n个位置。通过观察，可以发现旋转结果可以通过三次反转实现，只需要自己写一个翻转方法即可

     ```java
     nums = "----->-->"; k =3
     result = "-->----->";
     
     reverse "----->-->" we can get "<--<-----"
     reverse "<--" we can get "--><-----"
     reverse "<-----" we can get "-->----->"
     this visualization help me figure it out :)
     ```



##### #190 颠倒二进制位

> 位运算

- 思路
  1. 通过位运算使得不需要拆散int为每一个数字，直接修改



##### #191 位1的个数

> 位运算

- 思路
  1. 将数字转为二进制形式的字符串，然后遍历'1'的个数
  2. 可以不转换为字符串，而是通过位运算逐步检查
  3. 可以利用位运算技巧（#231）不断清除最低位0



##### #198 打家劫舍:star:

> 动态规划

- 思路
  1. 只要找到动态规划方程，问题就可以迎刃而解。方程的左侧是答案，右侧是解法。



##### #200 岛屿数量

##### #203 移除链表元素



##### #209 长度最小的子数组

1.   双指针 同713
2.   前缀和+二分查找




##### #213 打家劫舍Ⅱ


##### #217 查重



##### #221 最大正方形

1.  暴力与动态规划

    -   设每个遍历坐标matrix\[i][j]为正方形的右下角，并使用dp数组记录该位置的最大正方形
    -   若该值不为1，则必然不是正方形
    -   若该值为1，则通过dp\[i-1][j-1]获取其边长pa，故设当前位置边长a=pa+1，然后确认dp\[i-a..i][j]以及dp\[i][j-a..j]所有位置是否都为1，若是，则将边长a计入dp数组中，否则将边长a减小后重新遍历，直到找到符合的值

2.  动态规划

    -   既然想通过动态规划解决问题，那么可以考虑有没有无需遍历的方式，所以联想到了当前位置的上侧和左侧。

    -   发现关系：

        ```
        f[i][j - 1] >= f[i][j] - 1
        f[i - 1][j] >= f[i][j] - 1
        f[i - 1][j - 1] >= f[i][j] - 1
        ```

        将这三个不等式联立后，得到

        `f[i][j] ≤ min{f[i-1][j],f[i][j-1],f[i-1][j-1]}+1`

    -   得到该方程式后，将不再需要使用暴力解法



##### #226 翻转二叉树

> 二叉树

- 思路
  1. 使用递归对其左右借点进行交换
- 提示
  - 没能够做出来是因为忽略了这是节点的切换而不是数值的切换的事实，所以觉得无法使用递归



##### #230 二叉搜索树中第k小的元素

1.   映射后排序
     -   通过dfs将树映射成链表的形式，排序后取地k个值
     -   这种做法显然没有利用到搜索树的性质
2.   中序遍历
     -   对于二叉搜索树，其中序遍历后的结果就是有序的。因此只需要找到第k个值就可以返回



##### #231 2的幂

> 位运算

- 思路

  1. 通过递归不断除以2来判断。若除以2有余数则返回false。注意0要分类讨论
  2. 使用如下二进制运算技巧
  3. 只需要判断n是否位2^30^的约数同样可以

- 技巧

  - `n & (n - 1)`：清除最低位的1。若其值为0，则是2的幂

  - `n & (-n)`：直接获取二进制表示的最低位的 1。若其值与n相等，则是2的幂

  - 部分语言中，位运算优先级可能较低，需要注意运算顺序
    - java中，与运算是`&` 



##### #236 二叉树的最近公共祖先

1.   中序遍历
     -   因为树不是可以直观处理的数据结构，所以想到映射后处理。
     -   因为中序遍历能够反映左右子树，因此想到了先获取树的中序遍历的数组，再使用双指针完成题解
     -   最初的做法超时了，因为中序遍历中获取每颗子树的index都需要遍历一次数组，所以后来改用哈希表存储数据后成功了
     -   超过40分钟了啊！
2.   哈希表
     -   使用map记录每个节点的父节点，然后从p和q同时向上移动并将位置信息记录在set中
     -   如果发现当前路径已在set中，则为公共祖先
3.   递归
     -   递归过程旨在找到最近的公共祖先，这个祖先的判断条件可以找到，最终发现其只需要判断当前节点的左右子树是否包括了p或者q即可，也不需要直到是确切哪一个
     -   使用递归是三种方法中唯一可以做到一次遍历的

-   思考
    -   想到映射自认为很不错，但是中序遍历的本质仍是在使用树结构，所以映射处理没必要
    -   总是觉得递归一定是最糟糕的，但这题反而递归是最佳做法
    -   首先应该思考从当前节点怎么判断，情况可以分为：最近公共祖先之上、之下



##### #238 除自身以外数组的乘积

-   思路
    1.  因为数组中存在0，所以没有办法通过除法得到数组。可以使用暴力为每个数字都遍历一遍乘积。为了优化暴力算法，将遍历时在元素i之前的乘积保存起来。因为想到i之后的乘积总会不断减少，所以没想到优化的方法了
    2.  通过从后往前遍历同样能够获得累计乘积，于是只需要两次遍历这个数组即可解决问题



##### #240 搜索二维矩阵Ⅱ

>   双指针

-   思路
    1.  因为矩阵从上到下有序，从左到右有序，但两个有序似乎不相干，所以遍历了矩阵的列，并对其每一行进行二分查找。时间复杂度是O(mlogn)，因为最多要进行m次二分查找
    2.  该思路利用了两个有序：期望从右下角开始以斜线的形式遍历矩阵。若当前值比target小，则右移；否则上移



##### #242 有效的字母异位词



##### #264 丑数

1.   暴力
     -   丑数是只包含质数2、3、5的数字，若当前数字除以2、3、5后，得到的数字应该也是丑数且被遍历过。于是使用哈希表记录遍历过的丑数，然后从1开始遍历，使用此方法判断是否为丑数，直到找到第n个丑数为止。该方法尽管时间复杂度为O(n)，但是实际上当数值变大后，丑数会越来越难遇到，故导致超时了
2.   最小堆
     -   与其不断遍历来寻找丑数，不如自己创造这些丑数。因为丑数只由2、3、5组成，因此可以通过丑数键的组合相乘找到结果
     -   但是组合过程中遇到了困难：如何组合，如何遍历直到得到结果为止，以及如何确保得到的结果确实是第n个丑数
     -   最小堆方法使用了堆PriorityQueue来保证数据顺序，使用了哈希表来查重。从堆中取出当前最小的元素x，并将2x、3x、5x检查是否没有重复，然后加入堆中。为了保证顺序是正确的，所以该过程直到堆中取出了第n个元素才算完成
     -   从堆中取出1个元素并加入3个元素的时间复杂度为O(4log_3n)=O(log_n)，因此总时间复杂度为O(n*log_n)
3.   动态规划
     -   最小堆的方法会预先存储较多的丑数，导致空间复杂度很高；维护最小堆的过程也导致时间复杂度很高，于是想到使用动态规划进行优化
     -   定义数组dp，其中dp[i]代表第i个丑数，有dp[1]=1
     -   维护三个指针p2，p3，p5指向的是当dp[p2]\*2，dp[p3]\*3，dp[p5]*5的值。当遍历到dp[i]时，dp[i]为这三者中找到最小的值。最终应该返回dp[n]



##### #283 移动零

> 双指针

- 思路
  1. 非零往前补，然后补零。统计了0的个数以确定需要移动多少位。但是过程中出现了溢出、连续为0的情况，没有处理好。且代码略复杂
  2. 应该忽略0的存在。左指针总是指向非零部分的结尾处，右指针不断检查下一位是否为零，需遍历整个数组。指针可以藏在循环里（这里右指针是以foreach形式展现的）



##### #278 第一个错误的版本

> 双指针-二分查找

- 思路
  1. 因为答案在某一点处，且该点前后内容有区分度，所以使用二分查找。
- 技巧
  - 二分查找中，假设循环内经过比较后，出现了`left = mid`时，mid的计算应该为`int mid = (left+right+1)>>>1`，这样可以防止left==mid时进入死循环。而出现`right = mid`时



##### #290 单词规律

-   思路
    1.  使用map判断是否单向映射，使用set排除重复映射



##### #300 最长递增子序列

1.  动态规划
    -   动态规划第一步要考虑的是如何将问题规模减小。对于数组有两种思路：规模每次减小一半、规模每次减小一个。简化问题的方式则是定义dp[i] 为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度，且nums[i] 必须被选取，这样，不断遍历并记住最大值即可得到结果
1.  贪心
    -   贪心算法需要知道一次遍历的过程中，如何让被选中的值组成的序列最大。对于此题，显然遇到更大的值应该让其直接加入序列，遇到更小的值则考虑替换序列中恰好比它大的值。就像打麻将一样，用更好的值替换掉次好的值
    -   因为对于更小的值，需要考虑其加入队伍的位置，所以需要维护一个数组作为最长上升子序列



##### #303 区域和检索

1.  暴力
2.  一维前缀和
    -   因为暴力法需要多次遍历该数组，所以如果能够为数组进行预处理，使得求和过程能够尽可能地快就可以省下时间
    -   使用前缀和优化时间复杂度。预处理中，记录每个位置及之前的和，在求和过程中，有`sum(i,j) = f(j+1)-f(i)`



##### #304 二维区域和检索

1.   暴力
2.   一维前缀和
     -   这是#303的二维形式题目，可以通过把每一列看作是一个单位，使用一维前缀和得到结果
3.   二维前缀和
     -   使用二维前缀和优化一维前缀和。这里思考到了矩阵面积的相减：减去水平侧和垂直侧长方形，再加上减多了的小矩形



##### #309 最佳买卖股票时机含冷冻期

>   动态规划

-   思路
    1.  因为股票中暂时的决策可能会导致当前收益低但是最后收益高，所以应该使用多状态的动态规划。考虑到该题中，股票的购买有3种状态：持有中，冻结期，以及未购入，于是分三种状态进行动态规划即可



##### #334 递增的三元子序列

>   贪心、动态规划

-   思路
    1.  暴力：3次遍历，得到从左开始的最小值、从右开始的最大值，以及最后一遍：遍历是否有同时符合的数
    2.  贪心1：考虑到一个递增的三元子序列数字递增，first总是遍历过程中的最小值，second只需要大于first即可，同时应该尽量地小，接着只要找到一个比second大的值即可，因此只需要一次遍历即可找到答案
    3.  此题是#300的简单版，所以使用动态规划和贪心都可以




##### #344 反转字符串

> 双指针

- 思路：双指针往中间靠拢



##### #376 摆动序列

1.   动态规划

     -   此题是#300的升级版，因为摆动序列涉及到两个状态：结尾上升、结尾下降，因此需要使用两个数组以维护两个状态，并且按顺序遍历数组，假设当前最佳结果包括了当前遍历值i
     -   遍历i之前的所有值以确保不会漏，若前面的值比i大，则使用其下降状态的值，反之使用其上升状态的值。遍历过程中维护最大值
     -   时间复杂度为O(n^2^)，空间复杂度为O(n)

2.   动态规划 优化

     -   因为存在两个状态，所以需要考虑之前的所有值都通过了这两个状态展现出来了。所以将状态数组定义为当前位置的最大值，得到状态转移方程。对于下降状态，状态转移方程同理

     $$
     up[i]=\left\{
      	\begin{aligned}
      	up[i-1],比前一位小 \\
      	max(up[i-1], down[i-1]+1), 比前一位大
      	\end{aligned}
      \right.
     $$

     -   因为仅需要前一个状态来进行转移，因此没有必要维护数组。此时时间复杂度为O(n)，空间复杂度为O(1)
     -   为什么这一题可以仅依靠前一个状态来转移，而不像#300一样需要逐个遍历呢？

3.   贪心

     -   为了让序列尽可能长，只需要将序列中的峰和谷的数量记录下来即可



##### #409 最长回文串

-   思路
    1.  最为回文串，字符应该成对出现，而正中间的字符可以单独出现。于是只需要遍历见过的字符并统计即可



##### #413 等差数列划分

-   思路
    1.  动态规划。假设每个数的结尾都在这个数列之中，于是只需要不断统计个数即可
    2.  贪心。不断遍历以观察其步长值，直到步长值发生改变或者到达尾端的时候才计算个数



##### #415 字符串相加

> 字符串

- 思路：直接逐位相加。注意不要忘了进位
- 注意
  - 字符串的第0位在左边。可以使用StringBuffer的`.reverse()`方法



##### #435 无重叠区间

1.  动态规划
    -   首先是为整个数组排序。因为没有办法很好地遍历整个区间，为了能够用得上动态规划，这里令f~i~表示【以区间i结尾的最后一个区间，可以选出的区间数量的最大值】，从而得到转移方程$f_i=max_{符合条件的前区间}{f_i}+1$。遍历找到最大值即可
2.  贪心：假设当前位置是某一种最优选择方法的首个区间，那么其左侧没有其他区间，右侧则有若干个不重叠的区间。这时，只要其右侧足够小，就是最佳的首区间。不断把当前维护的区间当作首个区间，直到遇到下一个区间

-   提示
    -   没有想到用动态规划：涉及求最优解都应该想到动态规划
    -   这道题动态规划最迷惑性的地方是使用了和#300相似的，对付LIS的动态规划算法。这是动态规划的变形模板，间接地省略了选与不选两种状态，以树的最大深度形式形成动态规划数组，应该熟记
    -   使用Math.max()的速度远比不上+



##### #438 找到字符串中所有字母异位词

1.   （滑动窗口）哈希表
     -   对每个字符排序后比较
     
2.   滑动窗口（new int[26]）
     -   该方法能够大幅优化耗时
     
3.   滑动窗口优化
     -   因为每次都只让窗口移动一个位置，所以可以通过维护differ变量来感知数组间差距
     
     



##### #450 删除二叉搜索树中的节点

1.   中序遍历、二叉搜索树特性

-   思路
    -   二叉搜索树BST的三个特性
        -   二叉搜索树的中序遍历是递增序列
        -   中序遍历的下一个节点（后继节点），在BST中先取当前右节点，然后一直取该节点的左节点，直到左节点为空
        -   前驱节点则相反
    -   java特性
        -   当引用被传递给方法后，形参指向null不能够让实参指向null



##### #459 重复的子字符串

1.   暴力枚举
     -   先遍历得到子字符串符合要求的长度，然后不断截取该长度下的子字符串，并逐个使用equals来比较字符串
2.   字符串匹配
     -   令符合要求的字符串为s，字符串子串为s‘，如果移除字符串s的s’，然后保持顺序添加到末尾，那么得到的字符仍是s
     -   如果将两个s连在一起，并移除第一个和最后一个字符，那么得到的字符串一定包含s，即s是它的一个子串
     -   因此只需要一句话就可以判断是否符合要求
3.   KMP算法
     -   基于思路二，将其搜索替换为KMP

-   思路
    -   题解对于子字符串的利用十分出色



##### #494 目标和



##### #509 斐波那契数

> 动态规划

- 思路
  1. 使用递归
  2. 使用动态规划。因为每个斐波那契数的计算公式都由三个数组成，斐波那契数存在递推关系F(n)=F(n−1)+F(n−2)，因此可以使用动态规划求解。使用动态规划可以使得空间复杂度优化为O(1)



##### #516 最长回文子序列

1.   动态规划
     -   将每个位置的最长回文子串记录在数组中，由于每个位置包括了起点和终点，于是需要使用到二维数组。同#5



##### #518 零钱兑换Ⅱ :star: 

1.  动态规划-组合
    -   为了使得不会重复计算不同的序列，所以使硬币面额作为外层循环，价格作为内层循环。




##### #542 01矩阵

> bfs

- 思路
  1. 原来的思路是遍历每一个元素，若当前位置为1，则搜索最近的0。苦于无法利用相邻元素提高整体效率，所以超时了。
  1. 先找到所有的0并添加到队列中，然后开始遍历1有多远



##### #557 反转字符串中的单词

> 双指针

- 思路
  1. 先将字符串转为char[]，右指针不断右移寻找空格或字符串结束处，左指针则指向空格右边的字符，这样界定了一个单词，使用双指针靠拢进行反转。最后将char[]导入到StringBuffer中再转String
  2. Java不能直接操作String类型，所以一定需要开辟新空间，所以可以每找到一个单词就把他的倒序放入字符串中



##### #560 和为k的数组

-   思路
    1.  暴力。
    1.  前缀和+哈希表优化。首先定义pre[i]为[0..i]里所有数的和，因为[j..i]这个子数组的和为看，所以经过变换有如下条件：`pre[i]-pre[j-1]=k`，为了方便遍历，在移项得到：`pre[j-1]==pre[i]-k`。于是只需要把所有的pre[j-1]存储进哈希表，并在遍历的过程中不断查看是否有符合的值即可。此方法做到了用空间换时间
-   思考
    -   想到要使用for遍历，就思考能不能使用哈希表优化




##### #566 重塑矩阵



##### #567 字符串的排列

> 双指针-滑动窗口

- 思路
  1. 双指针，且以右指针为终点，向前s1的字符长度作为起点（这样规避了s1比s2长的情况），使用双数组判断是否字符数量相等。若发现s1中没有的字符，则直接以此位置下一位作起点；发现s1中出现的字符但是使用数量超过了，则右指针右移一位（因为无法判断从何处开始。写代码过程中忽视了这里）。运行结果性能排名不佳
  2. 优化1：实际上整个窗口有时只是右移了一个单位，但却对整个窗口内的字符串进行了重新统计。此外数组的对比可以使用`Arrays.equals()`。优化后耗时提升了近50ms
  3. 优化2：实际上也不需要对整个数组进行比较。使用了diff变量进行统计两者值不同的个数，并在修改前后查看所添加字符能否使得diff削减。同时为了简化逻辑，可以只使用一个数组：两个数组字母的差值数（一个减，一个加）
  4. 不是滑动窗口的方法：同样使用了一个差分cnt数组，但关注点只有cnt值是否为正（是否多了），以及左右指针拉开的长度是否等于s1的长度（是否没少）。字符串2不断右移并判断新加入的字符是否使得cnt值大于0，若有，则不断右移左指针直到这种情况消失。然后判断左右指针长度差是否相等。和上述方法比较，关注点少了，处理也更清晰，性能也得到了提升



##### #572 另一棵树的子树

1. 暴力递归
    -   遍历一棵树，并对每一个节点进行一次检查，确认是否该节点为subRoot节点
    -   时间复杂度为O(s*t)，空间复杂度为O(max{ds,dt})（树的深度）
2. 映射成串
    -   一棵子数上的点在DFS中是连续的。于是可以考虑先将两颗树转为字符序列，然后再匹配
    -   为了防止空节点对字符序列的干扰，这里引入了两个空值lNull和rNull，当一个节点左孩子或右孩子为空时，就插入这两个空值
    -   字符串的匹配可以使用暴力，也可以使用KMP或者Rabin-Karp算法，后者可以将时间复杂度优化至O(s+t)。空间复杂度为O(s+t)
3. 映射成哈希值

-   思考
    -   （当你有足够能力的时候）处理一棵树，将其映射后能够提高处理速度



##### #617 合并二叉树

> 树

- 思路
  1. 想着是用dfs，但是递归写得2不好，着重点在当前结点的左右结点，因为没有处理好非空的关系，所以失败了
  2. 答案的dfs着重点在当前结点上，每次进入函数先判断该节点是否为空，使得处理方便



##### #673 最长递增子序列的个数

1.   动态规划
     -   与#300是同样的思路，但由于此题需要获取的是最长子序列的个数，所以需要使用额外的数组记录其每个位置最长子序列的数量

-   思考
    -   对于自身而言肯定更偏向于使用性能更优的贪心算法，但是却不能够证明为什么这样贪心是正确的，最终变成了面向测试用例编程
    -   因为贪心没办法尝试出来，随后更换了动态规划，但既没写状态转移方程，又总是想着省去数组的使用，最终白白折腾了很久，写出来逻辑混乱的代码



##### #695 岛屿的最大面积

> 图

- 思路
  1. 不断按顺序遍历二维数组，若发现一个未遍历过的岛则开始测量其面积，并将遍历过的大陆标为2，使用的是广度优先。最终通过不断比较得到最大岛的面积。注意不要看错题，虽然岛的数量和最大岛面积数值一样
- 感想
  - 深度优先和广度优先算法的区别就在于广度优先核心是队列，而深度优先核心是栈（递归可以用栈（Deque）代替）



##### #704 二分查找

> 双指针-二分查找

- 思路

  1. 因为数组元素有序，所以使用二分查找

- 二分查找算法:star:

  ```java
  public int search(int[] nums, int target){
  	int mid, l = 0, r = nums.length-1;
  	while(l<=r){
  		mid = (r+l)/2;
      // mid = l + (r-l)/2
      // 等效写法，但是能够避免溢出
      if(target<nums[mid]) r = mid - 1;
      else if(target>nums[mid]) l = mid + 1;
      else return mid;
  	}
  	return -1;
  }
  ```

  - 注意观察如何避免数组只有一个元素时进入不了循环
  - 注意左指针和右指针和mid指针的区别，这应该和答案区间有关，也是为了让指针最后能够相等，以及退出循环



##### #706 设计哈希映射

1.   哈希值的使用
     -   base为一个常数，这里选择了质数769
     -   哈希值通过整数除以base得到，并使用base个链表数组用于储存数据



##### #707 设计链表



##### #713 乘积小于k的子数组

1.   暴力
     -   因为在连续数组中，一旦值超过target，则之后的乘积都会超过target。使用该思路进行剪枝
2.   二分查找
     -   因为担心运算过程中，乘积会溢出，所以使用了对数运算来代替
     -   使用思路1的剪枝思路，并使用二分查找找到这个临界值
3.   双指针
     -   因为数组中只有正整数，那么乘积总是会因为乘法因子的个数而增大。意思是只要维护一定数量的乘法样子，乘积就会小于k。因此使用双指针进行遍历
     -   以右指针作为子数组右端点，通过调整左指针使得乘积刚好达到不越界的最大乘积。那么，在此区间内的子数组都符合题目要求，数量为right-left+1
     -   这样使得时间复杂度为O(n)


-   思考
    -   思考答案的来源是否可追溯



##### #714 买卖股票的最佳时机含手续费

>   动态规划、贪心

-   思路
    1.  见309
    2.  使用贪心算法：对于股票，只要每次出现扣除手续费后仍能够盈利的情况就是将其统计，最后得到总盈利



##### #733 图像渲染

> 图

- 思路

  1. 广度优先：不断把未更换前颜色的区域加入到队列中，通过换成最新颜色、出队表示遍历过的区域，当出现更换前颜色与更换后颜色相同的情况时应该直接返回原数组，否则会出现死循环
  2. 深度优先：

- 提示

  1. 数组是可以加到队列中的

     ```java
     Queue<int[]> queue = new LinkedList<int[]>();
     queue.offer(new int[]{sr,sc});
     ```

  2. 不用直接为上下左右四个方向各写1次判断，可以添加到数组，然后通过循环操作

     ```java
     int[] dx = {1, 0, 0, -1};
     int[] dy = {0, 1, -1, 0};
     // 上下左右
     ```



##### #739 每日温度

1.   暴力
     -   时间复杂度为O(n^2^)
2.   单调栈
     -   如果需要找到左边或者右边第一个比当前位置的数大或者小，则可以考虑使用单调栈
     -   考虑到温度信息会在找到下一个更高温度后就无效，于是使用了单调栈。单调栈为空或者栈顶元素大于当前温度时，将温度加入栈；否则，不断出栈直到栈为空或者栈顶元素大于当前温度




##### #746 使用最小花费爬楼梯

> 动态规划

- 思路
  1. 虽然使用了递归，导致运行超时，但是得到的状态转移方程是可以的：`f(n) = min(f(n-1), f(n-2))+pay` 
  2. 递归只是一种描述方式，使用滚动数组直到获取答案显然对空间复杂度更友好。其次，官方的状态转移方程如下：`dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])`，这样的方程不需要为末项专门设置条件语句
- 提示
  - 在状态转移方程存在递进关系的时候，使用滚动数组可以优化算法



##### #763 划分字母区间

>   贪心

-   思路
    1.  首先要了解每个字母的最后一次出现的位置，然后使用贪心划分尽可能多的片段。由于对于每个访问过的字母c，得到了最后一次出现的下标end_c时，则当前片段结束的下标一定不会小于end_c，因此有`end = max(end, end_c)`



##### #784 字母大小写全排列

> 全排列



##### #797 所有可能的路径

1.   DFS



##### #844 比较含退格的字符串

1.   重构字符串
     -   先得到两者被处理后的字符串，然后再比较字符串是否相等。可以使用栈或者双指针得到
     -   时间复杂度为O(N+M)，空间复杂度为O(N+M)
2.   双指针
     -   一个字符是否会被删除，取决于该字符后面的退格符。因此，从后往前一次遍历，可以方便地知道该字符是否会被删除
     -   这样提供了让两个字符串同时遍历的可能。两个字符串同时不断地逆序遍历字符串得到会被保留的字符，若对应的字符不相等，则说明最终字符串也不相等
     -   时间复杂度为O(N+M)，空间复杂度为O(1)

-   提示
    -   若出现两个列表之间的比较，则应该思考是否能够不经过预处理就开始同时比较
    -   




##### #876 链表的中间结点

> 双指针

- 思路
  1. 快慢指针



##### #896 单调数列

1.   一次遍历
     -   一定要留意差值为0的情况以及位置，否则会拼命踩坑



##### #918 环形子数组的最大和 :star: 

>   贪心、动态规划

-   思路
    1.  为了解决环形子数组的遍历不方便的问题，我将两个原数组凑成了一个新数组。但是由于无法解决子数组超过最大长度的问题，因此无法完成
    2.  可以把原数组中元素分为在子数组内的元素和其他未被选择的元素。这样，两者总有一部分是相连未被分割的，当未被分割的部分为其他元素时，通过总和减去这部分元素和得到的结果就是子数组之和。子数组内的元素加起来是当前位置前的最大值，则剩下的元素是当前位置下的最小值，因此只需要一次遍历，并同时查找最大值和最小值，然后在返回结果的过程中比较哪个更大即可。要注意的是，假若最小数组占用了数组的所有元素时，不能直接返回（总和-最小），因为此时理论下的子数组没有元素，这不符合题意
    3.  子数组的组成有两种情况：一个区间，或者首尾两个区间。事实上分类讨论也不难，一个区间的情况很好做，而两个区间的情况则是先为头部区间遍历得到[0,i]之间的最大值，然后再根据左指针的位置提供这个最大值



##### #931 下降路径最小和



##### #977 有序数组的平方

> 双指针

- 思路
  1. 因为数组有序，所以用双指针。先找到正负交界处，然后双指针不断往外扩散，直到填满整个数组为止
  2. 同样是使用双指针，但是可以把指针指向数组两端，不需要判断正负，只需要不断比较指针处平方结果，并按照从大到小的顺序放入数组，直到指针相遇



##### #997 找到小镇的法官

1.   双哈希表
     -   set用于放入不可能是法官的人，而map用于放入有可能是法官的人选
     -   最后查看候选人是否只有1个且是否有n-1人都给法官投票了
2.   统计节点的入度和出度
     -   毕竟法官不会信任人，但被所有人信任，于是统计所有人信任数量和被信任数量，然后找到匹配的即可
     -   使用数组比哈希表速度更快



##### #1014 最佳观光组合

>   动态规划

-   思路
    1.  暴力：时间复杂度为O(n^2^)，固超时
    2.  要解决超时问题只需要做到空间换时间即可，于是通过观察，发现对于景点而言，最佳景点假若不是因为重复或冲突，都是同一个，于是使用优先队列PriorityQueue排序得到下一个最佳景点。
    3.  `values[i] + values[j] + i - j`。这是题目的公式，可以拆为`values[i]+i`和`values[j]-j`。因为在遍历i或j时，另一个的最大值始终不变，于是可以遍历j，`max(values[i]+i)`的值则可以边遍历边维护。该做法与思路2大致相同，只不过其最大值的诞生思路2是在遍历者后方，要先使用优先队列获得，思路3则是一边遍历一边维护。其次，思路2的获取是通过观察现象得来的，而思路3是通过观察公式得来的，显然后者更优



##### #1091 二进制矩阵中的最短路径

1.   BFS
     -   如果在遍历过程中不希望更改原矩阵，则需要考虑记录遍历过的位置
     -   使用哈希表以及自定义的位置类，要注意自定义类需要重写equals()和hashCode()方法
     -   但上网搜索后发现使用新的boolean二维数组来记录位置是更好的选择



##### #1137 第N个泰波那契数

- 思路
  1. 见#509



##### #1143 最长公共子序列

1.   动态规划

     -   创建动态数组dp，其中dp\[i][j]表示text1[0:i]和text2[0:j]的最长公共子序列的长度。得到状态转移方程

         ```
         dp(i,j)=dp(i-1, j-1)+1, text1[i-1]==text2[j-1]
         dp(i,j)=max{dp(i-1,j),dp(i,j-1)}, other
         ```

-   思路
    -   使用二维动态规划的时候：两个迭代器



##### #1249 移除无效的括号

1.   使用栈
2.   两次遍历
     -   使用栈只是为了确保删除多余而无法一次便察觉的'('，但是这可以通过第二次遍历，从右往左删除



##### #1314 矩阵区域和

1.   二维前缀和
     -   为了提高计算速度，显然需要做空间换时间，于是使用了二维前缀和



##### #1567 乘积为正数的最长子数组长度

>   动态规划

-   思路
    1.  该思路由#152思路一更改而得到
    2.  该思路与#152思路二类似，同时维护i的正数最长数组长度和负数最长数组长度



##### #1823 找出游戏的获胜者

1.   暴力模拟

     -   用链表来模拟环
     -   使用双链表来提高速度

2.   动态规划

     -   因为过程涉及状态的变化，因此应该想到使用动态规划
     -   第一轮状态记作f(n,k)，下一轮则记作f(n-1,k)，如果能够找到n个人参赛与n-1个人参赛的最终胜出者之间的关系，就能够推导出状态转移公式
     -   画表格比较

     ```
     初始:		1,2,...,k-1,k,k+1,...n
     淘汰后:	1,2,...,k-1,k+1,...n
     下一轮:	k+1,...,n-1,n,1,...,k-1
     ------
     假设知道下一轮的胜出者为x，即f(n-1,k)=x，则有
     默认视角：	1,2,...,x-1,x,x+1,...n
     偏移后：	 k+1,...,k+x,...,k-1
     ```

     -   可以发现偏移量为k，因此得到状态转移方程：

         `f(n,k)=(f(n-1,k)+k-1)%i+1` （为防止刚好整除的情形导致取模为0，对原值-1后再对模+1）。而当只有一个人参赛时，最终结果只有他自己，即`f(1,k)=1`

     -   根据状态转移方程可以发现当前状态只与前一项有关，因此优化后，时间复杂度为O(n)，而空间复杂度为O(1)

-   思考
    -   状态的改变要想到动态规划



##### #5863 统计特殊四元组

> 数组

- 思路
  1. 通过循环初始条件使得四个元素皆不相同，然后通过四重循环条件得到题解



##### #5864 游戏中弱角色的数量

>数组

- 思路
  1. 应该控制顺序，先比较第一个数并排好序，再比较第二个数是否比排序在其前最小一个数还要小。二维数组的排序可以通过`Arrays.sort(T[] a, Comparator<? super T> c)`重写其`compare()`方法，再自定义比较



##### #5868 可互换矩形的数组

- 思路

  1. 忽略了返回类型是long类型，也缺乏对数字最大值的概念，所以出了错

- 提示

  1. 哈希表HashMap同样可以遍历。除此之外，foreach变量可以把各种类型用var指代

     ```java
     for (var x:map.values()) { // long x:
                 cnt += x*(x-1)/2;
     }
     ```

  2. 哈希表的修改、添加可以简写（有则加一，无则加入）

     ```java
     for(var data:rectangles){
                 double convert = (double)data[0]/data[1];
                 map.put(convert, map.getOrDefault(convert, 0L)+1L);
           }
     ```

     

##### #6017 向数组中追加k个整数

1.   暴力
     -   先对该数组进行排序，然后从0开始遍历，检查当前值是否在数组中，如果不在，则加起来。尽管该方法的时间复杂度为O(n)，但是由于数值十分大，所以还是超时了
2.   







