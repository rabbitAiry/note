# 力扣刷题笔记

[TOC]

##### #1 两数之和

> 归一

- 思路
  1. 假若有符合答案，则其实只要找到一个数，并确定是否存在一个数使得两者和为答案即可



##### #2 两数相加

> 链表

- 思路
  1. 一开始思路是将链表的数字转换为int类型，但是无法处理溢出的情况
  2. 直接对链表每个数相加可以更快地得出结果



##### #3 无重复字符的最长子串

> 双指针-滑动窗口

- 思路
  1. 把左指针都看作起点，右指针不断往右查看不重复的字符串最多能够有多长。通过将字符加入HashSet验证是否有重复，最终返回最大值
  2. 左指针作为字符串的起点，右指针则不断验证新的字符是否能够被加入到字符串中。通过将字符加入Queue中进行管理，若发现有重复，即不断使元素出队，直到重复元素出队为止。此方法相当于把右指针看作终点，因为使用右指针探路不容易溢出，所以此方法比思路一更容易操作



##### #5 最长回文子串

```
双指针
动态规划
```

- 思路
  1. 利用回文串的特点，不断遍历字符串，并对字符串的每个字符向外扩展并判断是否为回文。
  2. (1+)事实上左指针和右指针能够转换为当前最大长度和中间位置，使用并记录扩展步数更是多余的，所以可以将向外扩展分离为单独的函数。此外，虽然该算法只是从字符串每个字符向外扩展，但是每次扩展最多会扩展O(n)次，所以该算法的时间复杂度是O(n^2^)
  3. 使用动态规划：从你可以保证的开始，逐步往外扩展，这是动态规划。能够知道的是长度为1的必为回文子串；若某个子串是回文子串，则其两端相等，且左右各缩一步也是回文子串。以长度为突破口，将结果记录在二维数组中，最终得出最长子串。时间复杂度是O(n^2^),但耗时提升大，空间复杂度也相比上一种方法更复杂，为 O(n^2^)



##### #6 Z字形变换

> 数组

- 思路
  1. 可以按照z字形顺序来访问字符串
  2. 也可以构建行数个StringBuffer，按照顺序访问字符串，并依次添加到对应的StringBuffer中



##### #7 整数翻转

> 数学

- 思路
  1. 这道题的重头戏在如何处理正负，以及如何判断溢出。值得一提的是，java中负数的除法、求余得到的都是负数，所以正负数的操作是一致的。判断上可以先判断当前值是否大于最大值除以10，再比较加上的数是否会大于最大值mod10
  2. 答案的方法，通过简单的不等式和讨论条件推导，使得判断条件变得格外简单。在设计计算的问题上，不妨也先这样试一下



##### #8 字符串转换整数

- 思路
  1. 按题目要求即可，但是特别多的细节需要注意。特别注意的是，当一个数为负数且需要比较其添加值是否溢出时，不能直接用最小值余10在前面加个负号，因为有无负号结果皆为负数



##### #9 回文数

- 思路
  1. 把数字转为String类型后，直接双指针从两端遍历
  2. 不转换为字符串，将原数字的一半数拿出来作为一个新的数字，最后比较这两个数是否相同或者等于新数字除以10



##### #11 盛最多水的容器

> 双指针

- 思路
  1. 让数组中的数两两组合(i, j，两个循环)计算面积，然后找到其中最大值。但是这会超时
  2. 根据思路1优化。由 area = h * l 对外循环的i进行限制：若该数字比前一位小，则意味着h、l都减小了，不可能再次产生最大值，因此跳过。能通过但耗时较长
  3. 根据area = min(h~i~, h~j~) * L，使用双指针的方法。指针从两头移至中间，每次都会移动较小值并计算面积，最后找到最大值。复杂度从O(n^2^)降至O(n)。最后通过证明移动较大数不能够使得面积增大，证明了该方法的可行性



##### #12 整数转罗马数字

- 思路
  1. 罗列出所有可能性，叠加



##### #13 罗马数字转整数

- 思路
  1. 通过判断下一个char所代表的数字比当前char代表数字要大来判定：当前是一个字母代表一个数字还是两个字母（如：IV）代表一个数字



##### #15 三数之和

```
双指针
```

- 思路
  1. 暴力三循环：为了保证题目的【没有重复元素】，所以选择数组的排序为起点，排序后在循环过程中查重。但是这个时间复杂度为O(n^3^)的算法超时了
  2. 一重循环加双指针：事实上并非循环就一定能够得到结果。由于已经排过序了，可见第二个元素向右递增且第三个元素向右递增时，三者之和只会越来越大；只有第三个元素向左递减时才有可能让结果维持为0。因为找到了两个元素之间的联系，所以可以用得上双指针：当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2^)减少至 O(N)。再加上第一重循环，所以时间复杂度为O(N^2^)
- 提示
  1.  有顺序的数组可以使用双指针节省循环时间




##### #16 最接近的三数之和

> 双指针

- 思路
  1. 与15类似。但是有一点要注意，最大值尽量不要直接写Integer.MAX_VALUE，而是依据题目设定，尤其是出现最大值减去一个负数的时候



##### #17 电话号码的字母组合

> 枚举、回溯（dfs）

- 思路
  1. 直接枚举即可，要注意安排顺序



##### #18 四数之和

> 双指针

- 思路
  1. 同三数之和。但是从前面的循环开始设置剪枝可以提高速度。不需要怕麻烦，因为剪枝处越接近起点，带来的性能提升很大



##### #19 删除链表的倒数第N个节点

> 双指针

- 思路
  1. 快慢指针，慢指针比快指针晚N+1步出发
  2. （优化）为头节点之前添加一个伪节点，这样可以方便处理头节点被删除的情况



##### #20 有效的括号



##### #33 搜索旋转排序数组

> 二分查找

- 思路
  1. 直接搜索
  2. 并不需要一定找到旋转点的起始值，只需要知道中间指针左右总有一边是有序的



##### #34 在排列数组中查找元素的第一个和最后一个位置

> 二分查找

- 思路
  1. 我的做法是通过二分查找找到target，然后从该位置扩散找到起始位和终点位。时间复杂度为O(logN+m)，m是值为target的数量
  2. 答案做法是通过两次二分查找找到起始位和终点。



##### #35 搜索插入位置

> 双指针-二分查找

- 思路
  1. 因为数组元素有序，所以使用二分查找



##### #36 有效的数独



##### #42 接雨水

>   贪心、动态规划

-   思路
    1.  使用贪心算法（暴力）。记录下遍历过程中的最大值，当遍历过程中出现前一位比当前位小时，统计能够装多少水
    2.  使用动态规划。对于下标i，下雨后能到达的最大高度取决于其左右两侧的最大高度的最小值。于是使用两个数组以存储左侧最大高度和右侧最大高度，然后遍历得到当前位置的高度最小值并统计起来。此算法使得时间复杂度降为O(n)
    3.  使用双指针优化动态规划。注意到下标i处能接的雨水由左侧最大高度数组和右侧最大高度数组决定，因此可以使用双指针和两个变量代替
-   提示
    -   动态规划的出发点是从某个下标开始的，而不是绝对的从头开始



##### #45 跳跃游戏Ⅱ

> 贪心

- 思路
  1. 遍历数组，使用新的数组用以记录到达该位置的最小值，在遍历过程中把能够到达的index填入步数，直到找到最后一位。
  2. 上述思路混淆了“可以跳跃”和“跳跃至”的概念。可以跳跃意味着选择更多，可以跳跃得越远绝对是越好的。因此不需要使用额外数组来记录到达位置的最小值，而仅需要记录步数即可



##### #46 全排列

- 提示
  - 全排列的交换应该包括自己与自己交换
  - 可以将数组转换成list来操作，以方便结果的添加；以及可以使用`Collections.swap()`方法来交换元素位置



##### #48 旋转图像

>   数组

-   思路
    1.  想要通过`.clone()`方法来克隆数组，但是因为是二维数组，所以终究新数组的变动会导致旧数组的变动。应该对每个元素都遍历一遍的方式来复制
    2.  通过公式推导出了要使用额外的变量来存储数字的变动方式
    3.  数组可以先经过水平轴翻转，然后再经过主对角线翻转以获得结果



##### #53 最大子序和

> 动态规划



##### #55 跳跃游戏

> 贪心

- 思路
  1. 从最后一位向前推测所能到达的位置是否包含0。该思路混淆了“可以跳跃”和“跳跃至”的概念。未尝试
  2. 从第一位开始遍历数组，不断探索每一个下标其能够到达的最远位置。若当前下标已经不可到达，则跳过该下标。时间复杂度优化为O(n)



##### #56 合并区间:star:

> 数组

- 思路
  1. 使用排序将区间解决了分组的问题。只要当前区间的左边界大于答案区间的右边界，即需要创建新分组。
- 提示
  - 要做的是解决问题，而不是考虑通用性
  - 如果不能够一眼望近地解决问题，则应该考虑使用线性方式，按顺序来解决问题。使用排序，使得看待问题的角度发生变化
  - 先解决了答案区间何时创建的问题，再解决答案区间内容的问题



##### #59 螺旋矩阵Ⅱ



##### #70 爬楼梯:star: 

> 动态规划

- 思路
  1. 用 f(x)f(x)f(x) 表示爬到第 xxx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：`f(x)=f(x−1)+f(x−2)` 
- 提示
  - 从题目中看出这条动态规划转移方程并不容易。原来的思路是依据爬楼梯过程中出现2的次数分组，然后再计算2的位置排列组合方式来计算答案，但是由于出现重复的情况无法排除，故不能完成题目



##### #73 矩阵置零



##### #74 搜索二维矩阵

> 二分查找

- 思路

  1. 直接使用二分查找
  2. 将矩阵看作是一个大的一维数组，然后使用二分查找

- 注意

  - 如果mid出现了指针不移位导致的死循环，可以如下处理

    `int mid = (left+right)/2; `



##### #75 颜色分类

> 排序

- 思路
  1. 直接使用`Arrays.sort()`
  2. 记录下所有数字出现次数，然后重新填充
  3. 因为题目数组只有3个数字，所以可以使用两个指针，将0移到前面，2移到后面



##### #77 组合

> 排列

- 提示

  - 添加新的数组队列应该如下

  ```java
  ans.add(new ArrayList<>(list));
  ```

  



##### #82 删除排序链表中的重复元素Ⅱ

> 链表

- 思路
  1. 一次遍历。要注意判断是否为空节点
- 提示
  - 只要找到解题顺序，问题就能解



##### #83 删除排序链表中的重复元素



##### #88 合并两个有序数组

> 数组

- 思路
  1. 先合并后排序
  2. 因为数组nums1[]的后半部分为空，因此可以从后往前排序



##### #91 解码方法

>   动态规划

-   思路
    1.  这是一道#77爬楼梯的增强版，在踏上这片楼梯之前，还需要先判断以下这片楼梯是否能够踏足。



##### #94 二叉树的中序遍历



##### #96 不同的二叉搜索树

1.  动态规划
    -   给定一个有序数列1..n，为了构建出一棵2二叉搜索树，可以遍历每个数字，并将该数字作为树根，将其左侧作为左子树，右侧作为右子树
    -   由于根的值不同，因此能保证每棵二叉搜索树是唯一的
    -   接着再按照同样的方法递归构造左子树和右子树。由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用，因此想到使用动态规划来求解本题
    -   定义G(n)为长度为n的序列能构造成的不同二叉搜索树的个数，F(i,n)是以i为根，序列长度为n的不同二叉搜索树的个数
    -   显然有如下式子：$G(n) = ∑_{i=1}^n(F(i,n))$ ，边界情况有`G(0)=1 G(1)=1`
    -   对于F(i,n)，则有如下公式`F(i,n) = G(i-1)*G(n-i)`
    -   因此只需要计算G(n)即可



##### #101 对称二叉树

> 树

- 思路
  1. bfs，对每一层进行一次对称检查。要注意不能漏掉值为null的节点，否则会产生伪对称的现象
  2. 通过同步移动两个指针来遍历这棵树：指针p右移时，q左移；指针p左移时，q右移，若两者值不相同则不对称



##### #102 二叉树的层序遍历



##### #104 二叉树的最大深度

> 树

- 思路
  1. 采用递归
  2. 采用bfs



##### #112 路径总和



##### #116 填充每个节点的下一个右侧节点

> 广度优先遍历

- 思路

  1. 写出算法即可

- 提示

  - 使用队列

  ```
  Queue<Node> queue = new LinkedList<Node>();
  ```

  - 获取下一个队列元素：peek()



##### #117 填充每个节点的下一个右侧节点指针 II

> BFS

- 思路
  1. 写出算法即可，时间复杂度和空间复杂度均为O(n)
  2. 既然每一层都可以通过next看作是链表，那么就可以不使用队列，而是通过链表的遍历来完成。这样的空间复杂度为O(1)
- 注意
  - 尽管一棵树的一层元素数量小于N，但是其每一层的队列的空间复杂度仍未O(n)



##### #118 杨辉三角

##### #119 杨辉三角Ⅱ

>   数组

-   思路

    1.  直接递推，使用二维数组记录整个三角。由于每一行只需要用到上一个数组，所以可以优化为只使用两个数组

    2.  优化为O(n)：递推式$C^i_n=C^i_{n-1}+C^{i-1}_{n-1}$表明，当前行第 i 项的计算只与上一行第i−1项及第i项有关。因此我们可以倒着计算当前行.

        



##### #120 三角形最小路径和

> 动态规划

- 思路
  1. `f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]`
  2. 使用该动态转移方程，对三角形底部最后一行的每一个元素查找一次最小值，并使用二维数组记录每一个位置的最小路径。由于路径值可能为0，所以需要使用额外的bool二维数组记录是否访问过。
  3. 上述过程可以进行优化。从每一层遍历得到最小路径结果并记录在二维数组中，从上到下遍历每一层，这样就不需要使用bool二维数组记录是否访问过该位置
  4. 空间复杂度优化至O(n)：仅使用一维数组，记录每上一行的数据



##### #121 买卖股票的最佳时机

##### #122 买卖股票的最佳时机Ⅱ



##### #136 只出现一次的数字

> 位运算

- 思路
  1. 通过异或运算找到唯一的数字`single^=i;`



##### #139 单词拆分

>   动态规划

-   思路
    1.  通过递归的方式，找到一个位置能够放一个单词后，接着找下一个。遗憾的是超时了
    2.  优化时间：将列表转哈希表，然后使用数组记录当前位置是否可到达，以减少思路1如同树形结构般，每次都要从头开始遍历。时间复杂度同样是O(n^2^)，但是更快速。写出动态规划转移方程：`dp[i]=dp[j] && check(s[j..i−1])`。
-   技巧
    -   尽管使用char[]比charAt()更快速，但是new String(Arrays.copyOfRange(ca))比string.substring()要慢很多



##### #141 环形链表

> 链表

- 思路
  1. 通过set来识别是否有重复的节点
  2. 通过快慢指针的运作是否会相遇来判断是否落入循环
  3. 通过改变链表的值以达到做标记的效果以区分是否落入循环
- 技巧
  - 没做出来的原因是不知道如何识别这是进入了循环



##### #144 二叉树的前序遍历



##### #145 二叉树的后序遍历



##### #152 乘积的最大子数组

>   动态规划

-   思路
    1.  显然，数组中只有0和负数会干扰乘积的最大，若只有正数的话，只需一直相乘就找到最大值了。解题的思路是动态规划，不断遍历，把第i个元素作为最大子数组的结尾，若遇到第一个负数，则记录负数前的乘积为before，若遇到第偶数个负数，则所有一起相乘，若遇到第奇数个负数，则除以若遇到0，则当做重新开始。这个思路体现了动态规划的思想，f(i)是结尾包括i的子数组的最大值，但是完全依靠着常识得出的结论，于是代码逻辑写得较乱，思考时间较长，但是其空间复杂度仅为O(1)
    2.  $f_{max}(i) = max^{n}_{i=1}\left[f_{max}(i-1)*a_i, f_{min}(i-1)*a_i,a_i\right]$ ,$f_{min}(i) = min^{n}_{i=1}\left[f_{max}(i-1)*a_i, f_{min}(i-1)*a_i,a_i\right]$ 。上述是该题的动态规划方程，并不拘泥于知道数据中遇到了多少个负数，而是把正值最大和负值绝对值最大共同遍历维护从而得到结果，简化了计算过程。需要思考到，如果动态规划涉及到了状态有可能不断变更，则不如两种状态一起遍历



##### #153 寻找旋转数组中的最小值

> 二分查找

- 思路
  1. 不断遍历数组，直到数组中出现小于数组最后一位值得数字。时间复杂度为O(n)
  2. 使用二分查找
- 提示
  - 一开始想到使用双指针往中间，但是会出现因为数组元素数量为单双数时需要分类讨论，没成功。需要分类讨论的解决方法容易出错。
  - 有序数组的范围锁定一定要想到使用二分查找



##### #167 两数之和Ⅱ：有序数组

> 双指针

- 思路
  1. 因为数组有序，所以自然会考虑使用双指针。证明可以假设此时某一指针已经到达target解的一个位置，说明此时不可能再大/小了



##### #189 旋转数组

> 数组、分析

- 思路

  1. 使用新的数组，直接求余拷贝

  2. 每次执行一次向右移动，执行n次。虽然容易理解，但性能不佳

  3. 环状替换：和方法1不同，只是暂时地保存被替换的元素到temp中。通过计算得知会有gcd(k,n)轮的循环，每轮循环中每个元素不断与后k位交换

  4. 基于以下事实：当数组元素向右移动n次后，尾部会有k mod n个元素移动至头部，其余元素则向后移动k mod n个位置。通过观察，可以发现旋转结果可以通过三次反转实现，只需要自己写一个翻转方法即可

     ```java
     nums = "----->-->"; k =3
     result = "-->----->";
     
     reverse "----->-->" we can get "<--<-----"
     reverse "<--" we can get "--><-----"
     reverse "<-----" we can get "-->----->"
     this visualization help me figure it out :)
     ```



##### #190 颠倒二进制位

> 位运算

- 思路
  1. 通过位运算使得不需要拆散int为每一个数字，直接修改



##### #191 位1的个数

> 位运算

- 思路
  1. 将数字转为二进制形式的字符串，然后遍历'1'的个数
  2. 可以不转换为字符串，而是通过位运算逐步检查
  3. 可以利用位运算技巧（#231）不断清除最低位0



##### #198 打家劫舍:star:

> 动态规划

- 思路
  1. 只要找到动态规划方程，问题就可以迎刃而解。方程的左侧是答案，右侧是解法。



##### #203 移除链表元素




##### #213 打家劫舍Ⅱ

- 思路
  - 见19




##### #217 查重



##### #226 翻转二叉树

> 二叉树

- 思路
  1. 使用递归对其左右借点进行交换
- 提示
  - 没能够做出来是因为忽略了这是节点的切换而不是数值的切换的事实，所以觉得无法使用递归



##### #231 2的幂

> 位运算

- 思路

  1. 通过递归不断除以2来判断。若除以2有余数则返回false。注意0要分类讨论
  2. 使用如下二进制运算技巧
  3. 只需要判断n是否位2^30^的约数同样可以

- 技巧

  - `n & (n - 1)`：清除最低位的1。若其值为0，则是2的幂

  - `n & (-n)`：直接获取二进制表示的最低位的 1。若其值与n相等，则是2的幂

  - 部分语言中，位运算优先级可能较低，需要注意运算顺序
    - java中，与运算是`&` 



##### #232 用栈实现队列



##### #238 除自身以外数组的乘积

-   思路
    1.  因为数组中存在0，所以没有办法通过除法得到数组。可以使用暴力为每个数字都遍历一遍乘积。为了优化暴力算法，将遍历时在元素i之前的乘积保存起来。因为想到i之后的乘积总会不断减少，所以没想到优化的方法了
    2.  通过从后往前遍历同样能够获得累计乘积，于是只需要两次遍历这个数组即可解决问题



##### #240 搜索二维矩阵Ⅱ

>   双指针

-   思路
    1.  因为矩阵从上到下有序，从左到右有序，但两个有序似乎不相干，所以遍历了矩阵的列，并对其每一行进行二分查找。时间复杂度是O(mlogn)，因为最多要进行m次二分查找
    2.  该思路利用了两个有序：期望从右下角开始以斜线的形式遍历矩阵。若当前值比target小，则右移；否则上移



##### #242 有效的字母异位词



##### #264 丑数

1.   暴力
     -   丑数是只包含质数2、3、5的数字，若当前数字除以2、3、5后，得到的数字应该也是丑数且被遍历过。于是使用哈希表记录遍历过的丑数，然后从1开始遍历，使用此方法判断是否为丑数，直到找到第n个丑数为止。该方法尽管时间复杂度为O(n)，但是实际上当数值变大后，丑数会越来越难遇到，故导致超时了
2.   最小堆
     -   与其不断遍历来寻找丑数，不如自己创造这些丑数。因为丑数只由2、3、5组成，因此可以通过丑数键的组合相乘找到结果
     -   但是组合过程中遇到了困难：如何组合，如何遍历直到得到结果为止，以及如何确保得到的结果确实是第n个丑数
     -   最小堆方法使用了堆PriorityQueue来保证数据顺序，使用了哈希表来查重。从堆中取出当前最小的元素x，并将2x、3x、5x检查是否没有重复，然后加入堆中。为了保证顺序是正确的，所以该过程直到堆中取出了第n个元素才算完成
     -   从堆中取出1个元素并加入3个元素的时间复杂度为O(4log_3n)=O(log_n)，因此总时间复杂度为O(n*log_n)
3.   动态规划
     -   最小堆的方法会预先存储较多的丑数，导致空间复杂度很高；维护最小堆的过程也导致时间复杂度很高，于是想到使用动态规划进行优化
     -   定义数组dp，其中dp[i]代表第i个丑数，有dp[1]=1
     -   维护三个指针p2，p3，p5指向的是当dp[p2]\*2，dp[p3]\*3，dp[p5]*5的值。当遍历到dp[i]时，dp[i]为这三者中找到最小的值。最终应该返回dp[n]



##### #283 移动零

> 双指针

- 思路
  1. 非零往前补，然后补零。统计了0的个数以确定需要移动多少位。但是过程中出现了溢出、连续为0的情况，没有处理好。且代码略复杂
  2. 应该忽略0的存在。左指针总是指向非零部分的结尾处，右指针不断检查下一位是否为零，需遍历整个数组。指针可以藏在循环里（这里右指针是以foreach形式展现的）



##### #278 第一个错误的版本

> 双指针-二分查找

- 思路
  1. 因为答案在某一点处，且该点前后内容有区分度，所以使用二分查找。
- 技巧
  - 二分查找中，假设循环内经过比较后，出现了`left = mid`时，mid的计算应该为`int mid = (left+right+1)>>>1`，这样可以防止left==mid时进入死循环。而出现`right = mid`时



##### #290 单词规律

-   思路
    1.  使用map判断是否单向映射，使用set排除重复映射



##### #300 最长递增子序列

>   动态规划、贪心

-   思路
    1.  动态规划：动态规划第一步要考虑的是如何将问题规模减小。对于数组有两种思路：规模每次减小一半、规模每次减小一个。简化问题的方式则是定义dp[i] 为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度，且nums[i] 必须被选取，这样，不断遍历并记住最大值即可得到结果
    1.  贪心：维护一个数组作为最长上升子序列，用len记录目前序列的长度，若遍历到的元素比当前序列的末尾要大，则加入该序列并令len++。由于只需要返回长度而子序列前面的内容并不太关心，因此倘若遍历到了一个比序列末尾要小的数，则将其替代序列中的元素



##### #303 区域和检索



##### #309 最佳买卖股票时机含冷冻期

>   动态规划

-   思路
    1.  因为股票中暂时的决策可能会导致当前收益低但是最后收益高，所以应该使用多状态的动态规划。考虑到该题中，股票的购买有3种状态：持有中，冻结期，以及未购入，于是分三种状态进行动态规划即可



##### #334 递增的三元子序列

>   贪心、动态规划

-   思路
    1.  暴力：3次遍历，得到从左开始的最小值、从右开始的最大值，以及最后一遍：遍历是否有同时符合的数
    2.  贪心1：考虑到一个递增的三元子序列数字递增，first总是遍历过程中的最小值，second只需要大于first即可，同时应该尽量地小，接着只要找到一个比second大的值即可，因此只需要一次遍历即可找到答案
    3.  此题是#300的简单版，所以使用动态规划和贪心都可以




##### #344 反转字符串

> 双指针

- 思路：双指针往中间靠拢



##### #383 赎金信



##### #387 字符串中的第一个唯一字符



##### #409 最长回文串

-   思路
    1.  最为回文串，字符应该成对出现，而正中间的字符可以单独出现。于是只需要遍历见过的字符并统计即可



##### #413 等差数列划分

-   思路
    1.  动态规划。假设每个数的结尾都在这个数列之中，于是只需要不断统计个数即可
    2.  贪心。不断遍历以观察其步长值，直到步长值发生改变或者到达尾端的时候才计算个数



##### #415 字符串相加

> 字符串

- 思路：直接逐位相加。注意不要忘了进位
- 注意
  - 字符串的第0位在左边。可以使用StringBuffer的`.reverse()`方法



##### #435 无重叠区间

>   动态规划、贪心

-   思路
    1.  动态规划：首先是为整个数组排序。因为没有办法很好地遍历整个区间，为了能够用得上动态规划，这里令f~i~表示【以区间i结尾的最后一个区间，可以选出的区间数量的最大值】，从而得到转移方程$f_i=max_{符合条件的前区间}{f_i}+1$。遍历找到最大值即可
    2.  贪心：假设当前位置是某一种最优选择方法的首个区间，那么其左侧没有其他区间，右侧则有若干个不重叠的区间。这时，只要其右侧足够小，就是最佳的首区间。不断把当前维护的区间当作首个区间，直到遇到下一个区间
-   提示
    -   动态规划没有思考出方法来的原因
        1.  思考转移方程的时候，总是没有想过利用其他状态



##### #509 斐波那契数

> 动态规划

- 思路
  1. 使用递归
  2. 使用动态规划。因为每个斐波那契数的计算公式都由三个数组成，斐波那契数存在递推关系F(n)=F(n−1)+F(n−2)，因此可以使用动态规划求解。使用动态规划可以使得空间复杂度优化为O(1)



##### #542 01矩阵

> bfs

- 思路
  1. 原来的思路是遍历每一个元素，若当前位置为1，则搜索最近的0。苦于无法利用相邻元素提高整体效率，所以超时了。
  1. 先找到所有的0并添加到队列中，然后开始遍历1有多远



##### #557 反转字符串中的单词

> 双指针

- 思路
  1. 先将字符串转为char[]，右指针不断右移寻找空格或字符串结束处，左指针则指向空格右边的字符，这样界定了一个单词，使用双指针靠拢进行反转。最后将char[]导入到StringBuffer中再转String
  2. Java不能直接操作String类型，所以一定需要开辟新空间，所以可以每找到一个单词就把他的倒序放入字符串中



##### #560 和为k的数组

-   思路
    1.  暴力。
    1.  前缀和+哈希表优化。首先定义pre[i]为[0..i]里所有数的和，因为[j..i]这个子数组的和为看，所以经过变换有如下条件：`pre[i]-pre[j-1]=k`，为了方便遍历，在移项得到：`pre[j-1]==pre[i]-k`。于是只需要把所有的pre[j-1]存储进哈希表，并在遍历的过程中不断查看是否有符合的值即可。此方法做到了用空间换时间



##### #566 重塑矩阵



##### #567 字符串的排列

> 双指针-滑动窗口

- 思路
  1. 双指针，且以右指针为终点，向前s1的字符长度作为起点（这样规避了s1比s2长的情况），使用双数组判断是否字符数量相等。若发现s1中没有的字符，则直接以此位置下一位作起点；发现s1中出现的字符但是使用数量超过了，则右指针右移一位（因为无法判断从何处开始。写代码过程中忽视了这里）。运行结果性能排名不佳
  2. 优化1：实际上整个窗口有时只是右移了一个单位，但却对整个窗口内的字符串进行了重新统计。此外数组的对比可以使用`Arrays.equals()`。优化后耗时提升了近50ms
  3. 优化2：实际上也不需要对整个数组进行比较。使用了diff变量进行统计两者值不同的个数，并在修改前后查看所添加字符能否使得diff削减。同时为了简化逻辑，可以只使用一个数组：两个数组字母的差值数（一个减，一个加）
  4. 不是滑动窗口的方法：同样使用了一个差分cnt数组，但关注点只有cnt值是否为正（是否多了），以及左右指针拉开的长度是否等于s1的长度（是否没少）。字符串2不断右移并判断新加入的字符是否使得cnt值大于0，若有，则不断右移左指针直到这种情况消失。然后判断左右指针长度差是否相等。和上述方法比较，关注点少了，处理也更清晰，性能也得到了提升



##### #572 另一棵树的子树

> 树

- 思路
  1. 使用dfs，对每个节点逐一检查
- 注意
  1. 一开始入手时代码写得十分的乱，左右孩子节点以及非空的探讨写得非常的乱，但其实这些逻辑是可以分开的



##### #617 合并二叉树

> 树

- 思路
  1. 想着是用dfs，但是递归写得2不好，着重点在当前结点的左右结点，因为没有处理好非空的关系，所以失败了
  2. 答案的dfs着重点在当前结点上，每次进入函数先判断该节点是否为空，使得处理方便



##### #695 岛屿的最大面积

> 图

- 思路
  1. 不断按顺序遍历二维数组，若发现一个未遍历过的岛则开始测量其面积，并将遍历过的大陆标为2，使用的是广度优先。最终通过不断比较得到最大岛的面积。注意不要看错题，虽然岛的数量和最大岛面积数值一样
- 感想
  - 深度优先和广度优先算法的区别就在于广度优先核心是队列，而深度优先核心是栈（递归可以用栈（Deque）代替）



##### #704 二分查找

> 双指针-二分查找

- 思路

  1. 因为数组元素有序，所以使用二分查找

- 二分查找算法:star:

  ```java
  public int search(int[] nums, int target){
  	int mid, l = 0, r = nums.length-1;
  	while(l<=r){
  		mid = (r+l)/2;
      // mid = l + (r-l)/2
      // 等效写法，但是能够避免溢出
      if(target<nums[mid]) r = mid - 1;
      else if(target>nums[mid]) l = mid + 1;
      else return mid;
  	}
  	return -1;
  }
  ```

  - 注意观察如何避免数组只有一个元素时进入不了循环
  - 注意左指针和右指针和mid指针的区别，这应该和答案区间有关，也是为了让指针最后能够相等，以及退出循环



##### #706 设计哈希映射



##### #714 买卖股票的最佳时机含手续费

>   动态规划、贪心

-   思路
    1.  见309
    2.  使用贪心算法：对于股票，只要每次出现扣除手续费后仍能够盈利的情况就是将其统计，最后得到总盈利



##### #733 图像渲染

> 图

- 思路

  1. 广度优先：不断把未更换前颜色的区域加入到队列中，通过换成最新颜色、出队表示遍历过的区域，当出现更换前颜色与更换后颜色相同的情况时应该直接返回原数组，否则会出现死循环
  2. 深度优先：

- 提示

  1. 数组是可以加到队列中的

     ```java
     Queue<int[]> queue = new LinkedList<int[]>();
     queue.offer(new int[]{sr,sc});
     ```

  2. 不用直接为上下左右四个方向各写1次判断，可以添加到数组，然后通过循环操作

     ```java
     int[] dx = {1, 0, 0, -1};
     int[] dy = {0, 1, -1, 0};
     // 上下左右
     ```




##### #746 使用最小花费爬楼梯

> 动态规划

- 思路
  1. 虽然使用了递归，导致运行超时，但是得到的状态转移方程是可以的：`f(n) = min(f(n-1), f(n-2))+pay` 
  2. 递归只是一种描述方式，使用滚动数组直到获取答案显然对空间复杂度更友好。其次，官方的状态转移方程如下：`dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])`，这样的方程不需要为末项专门设置条件语句
- 提示
  - 在状态转移方程存在递进关系的时候，使用滚动数组可以优化算法



##### #763 划分字母区间

>   贪心

-   思路
    1.  首先要了解每个字母的最后一次出现的位置，然后使用贪心划分尽可能多的片段。由于对于每个访问过的字母c，得到了最后一次出现的下标end_c时，则当前片段结束的下标一定不会小于end_c，因此有`end = max(end, end_c)`



##### #784 字母大小写全排列

> 全排列




##### #876 链表的中间结点

> 双指针

- 思路
  1. 快慢指针



##### #918 环形子数组的最大和 :star: 

>   贪心、动态规划

-   思路
    1.  为了解决环形子数组的遍历不方便的问题，我将两个原数组凑成了一个新数组。但是由于无法解决子数组超过最大长度的问题，因此无法完成
    2.  可以把原数组中元素分为在子数组内的元素和其他未被选择的元素。这样，两者总有一部分是相连未被分割的，当未被分割的部分为其他元素时，通过总和减去这部分元素和得到的结果就是子数组之和。子数组内的元素加起来是当前位置前的最大值，则剩下的元素是当前位置下的最小值，因此只需要一次遍历，并同时查找最大值和最小值，然后在返回结果的过程中比较哪个更大即可。要注意的是，假若最小数组占用了数组的所有元素时，不能直接返回（总和-最小），因为此时理论下的子数组没有元素，这不符合题意
    3.  子数组的组成有两种情况：一个区间，或者首尾两个区间。事实上分类讨论也不难，一个区间的情况很好做，而两个区间的情况则是先为头部区间遍历得到[0,i]之间的最大值，然后再根据左指针的位置提供这个最大值



##### #977 有序数组的平方

> 双指针

- 思路
  1. 因为数组有序，所以用双指针。先找到正负交界处，然后双指针不断往外扩散，直到填满整个数组为止
  2. 同样是使用双指针，但是可以把指针指向数组两端，不需要判断正负，只需要不断比较指针处平方结果，并按照从大到小的顺序放入数组，直到指针相遇



##### #994 腐烂的橘子

> bfs

- 思路
  1. 直接套模板



##### #1014 最佳观光组合

>   动态规划

-   思路
    1.  暴力：时间复杂度为O(n^2^)，固超时
    2.  要解决超时问题只需要做到空间换时间即可，于是通过观察，发现对于景点而言，最佳景点假若不是因为重复或冲突，都是同一个，于是使用优先队列PriorityQueue排序得到下一个最佳景点。
    3.  `values[i] + values[j] + i - j`。这是题目的公式，可以拆为`values[i]+i`和`values[j]-j`。因为在遍历i或j时，另一个的最大值始终不变，于是可以遍历j，`max(values[i]+i)`的值则可以边遍历边维护。该做法与思路2大致相同，只不过其最大值的诞生思路2是在遍历者后方，要先使用优先队列获得，思路3则是一边遍历一边维护。其次，思路2的获取是通过观察现象得来的，而思路3是通过观察公式得来的，显然后者更优



##### #1137 第N个泰波那契数

- 思路
  1. 见#509



##### #1567 乘积为正数的最长子数组长度

>   动态规划

-   思路
    1.  该思路由#152思路一更改而得到
    2.  该思路与#152思路二类似，同时维护i的正数最长数组长度和负数最长数组长度



##### #1603 设计停车系统



##### #5863 统计特殊四元组

> 数组

- 思路
  1. 通过循环初始条件使得四个元素皆不相同，然后通过四重循环条件得到题解



##### #5864 游戏中弱角色的数量

>数组

- 思路
  1. 应该控制顺序，先比较第一个数并排好序，再比较第二个数是否比排序在其前最小一个数还要小。二维数组的排序可以通过`Arrays.sort(T[] a, Comparator<? super T> c)`重写其`compare()`方法，再自定义比较



##### #5868 可互换矩形的数组

- 思路

  1. 忽略了返回类型是long类型，也缺乏对数字最大值的概念，所以出了错

- 提示

  1. 哈希表HashMap同样可以遍历。除此之外，foreach变量可以把各种类型用var指代

     ```java
     for (var x:map.values()) { // long x:
                 cnt += x*(x-1)/2;
     }
     ```

  2. 哈希表的修改、添加可以简写（有则加一，无则加入）

     ```java
     for(var data:rectangles){
                 double convert = (double)data[0]/data[1];
                 map.put(convert, map.getOrDefault(convert, 0L)+1L);
           }
     ```

     

##### #6017 向数组中追加k个整数

1.   暴力
     -   先对该数组进行排序，然后从0开始遍历，检查当前值是否在数组中，如果不在，则加起来。尽管该方法的时间复杂度为O(n)，但是由于数值十分大，所以还是超时了
2.   







