# 力扣刷题笔记

[TOC]

##### #1 两数之和

> 归一

- 思路
  1. 假若有符合答案，则其实只要找到一个数，并确定是否存在一个数使得两者和为答案即可



##### #2 两数相加

> 链表

- 思路
  1. 一开始思路是将链表的数字转换为int类型，但是无法处理溢出的情况
  2. 直接对链表每个数相加可以更快地得出结果



##### #3 无重复字符的最长子串

> 双指针-滑动窗口

- 思路
  1. 把左指针都看作起点，右指针不断往右查看不重复的字符串最多能够有多长。通过将字符加入HashSet验证是否有重复，最终返回最大值
  2. 左指针作为字符串的起点，右指针则不断验证新的字符是否能够被加入到字符串中。通过将字符加入Queue中进行管理，若发现有重复，即不断使元素出队，直到重复元素出队为止。此方法相当于把右指针看作终点，因为使用右指针探路不容易溢出，所以此方法比思路一更容易操作



##### #5 最长回文子串

```
双指针
动态规划
```

- 思路
  1. 利用回文串的特点，不断遍历字符串，并对字符串的每个字符向外扩展并判断是否为回文。
  2. (1+)事实上左指针和右指针能够转换为当前最大长度和中间位置，使用并记录扩展步数更是多余的，所以可以将向外扩展分离为单独的函数。此外，虽然该算法只是从字符串每个字符向外扩展，但是每次扩展最多会扩展O(n)次，所以该算法的时间复杂度是O(n^2^)
  3. 使用动态规划：从你可以保证的开始，逐步往外扩展，这是动态规划。能够知道的是长度为1的必为回文子串；若某个子串是回文子串，则其两端相等，且左右各缩一步也是回文子串。以长度为突破口，将结果记录在二维数组中，最终得出最长子串。时间复杂度是O(n^2^),但耗时提升大，空间复杂度也相比上一种方法更复杂，为 O(n^2^)



##### #6 Z字形变换

> 数组

- 思路
  1. 可以按照z字形顺序来访问字符串
  2. 也可以构建行数个StringBuffer，按照顺序访问字符串，并依次添加到对应的StringBuffer中



##### #7 整数翻转

> 数学

- 思路
  1. 这道题的重头戏在如何处理正负，以及如何判断溢出。值得一提的是，java中负数的除法、求余得到的都是负数，所以正负数的操作是一致的。判断上可以先判断当前值是否大于最大值除以10，再比较加上的数是否会大于最大值mod10
  2. 答案的方法，通过简单的不等式和讨论条件推导，使得判断条件变得格外简单。在设计计算的问题上，不妨也先这样试一下



##### #8 字符串转换整数

- 思路
  1. 按题目要求即可，但是特别多的细节需要注意。特别注意的是，当一个数为负数且需要比较其添加值是否溢出时，不能直接用最小值余10在前面加个负号，因为有无负号结果皆为负数



##### #9 回文数

- 思路
  1. 把数字转为String类型后，直接双指针从两端遍历
  2. 不转换为字符串，将原数字的一半数拿出来作为一个新的数字，最后比较这两个数是否相同或者等于新数字除以10



##### #11 盛最多水的容器

> 双指针

- 思路
  1. 让数组中的数两两组合(i, j，两个循环)计算面积，然后找到其中最大值。但是这会超时
  2. 根据思路1优化。由 area = h * l 对外循环的i进行限制：若该数字比前一位小，则意味着h、l都减小了，不可能再次产生最大值，因此跳过。能通过但耗时较长
  3. 根据area = min(h~i~, h~j~) * L，使用双指针的方法。指针从两头移至中间，每次都会移动较小值并计算面积，最后找到最大值。复杂度从O(n^2^)降至O(n)。最后通过证明移动较大数不能够使得面积增大，证明了该方法的可行性



##### #12 整数转罗马数字

- 思路
  1. 罗列出所有可能性，叠加



##### #13 罗马数字转整数

- 思路
  1. 通过判断下一个char所代表的数字比当前char代表数字要大来判定：当前是一个字母代表一个数字还是两个字母（如：IV）代表一个数字



##### #15 三数之和

```
双指针
```

- 思路
  1. 暴力三循环：为了保证题目的【没有重复元素】，所以选择数组的排序为起点，排序后在循环过程中查重。但是这个时间复杂度为O(n^3^)的算法超时了
  2. 一重循环加双指针：事实上并非循环就一定能够得到结果。由于已经排过序了，可见第二个元素向右递增且第三个元素向右递增时，三者之和只会越来越大；只有第三个元素向左递减时才有可能让结果维持为0。因为找到了两个元素之间的联系，所以可以用得上双指针：当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2^)减少至 O(N)。再加上第一重循环，所以时间复杂度为O(N^2^)



##### #16 最接近的三数之和

> 双指针

- 思路
  1. 与15类似。但是有一点要注意，最大值尽量不要直接写Integer.MAX_VALUE，而是依据题目设定，尤其是出现最大值减去一个负数的时候



##### #17 电话号码的字母组合

> 枚举、回溯（dfs）

- 思路
  1. 直接枚举即可，要注意安排顺序



##### #18 四数之和

> 双指针

- 思路
  1. 同三数之和。但是从前面的循环开始设置剪枝可以提高速度。不需要怕麻烦，因为剪枝处越接近起点，带来的性能提升很大



##### #19 删除链表的倒数第N个节点

> 双指针

- 思路
  1. 快慢指针，慢指针比快指针晚N+1步出发
  2. （优化）为头节点之前添加一个伪节点，这样可以方便处理头节点被删除的情况



##### #35 搜索插入位置

> 双指针-二分查找

- 思路
  1. 因为数组元素有序，所以使用二分查找



##### #116 填充每个节点的下一个右侧节点

> 广度优先遍历

- 思路

  1. 写出算法即可

- 提示

  - 使用队列

  ```
  Queue<Node> queue = new LinkedList<Node>();
  ```

  - 获取下一个队列元素：peek()



##### #167 两数之和Ⅱ：有序数组

> 双指针

- 思路
  1. 因为数组有序，所以自然会考虑使用双指针。证明可以假设此时某一指针已经到达target解的一个位置，说明此时不可能再大/小了



##### #189 旋转数组

> 数组、分析

- 思路

  1. 使用新的数组，直接求余拷贝

  2. 每次执行一次向右移动，执行n次。虽然容易理解，但性能不佳

  3. 环状替换：和方法1不同，只是暂时地保存被替换的元素到temp中。通过计算得知会有gcd(k,n)轮的循环，每轮循环中每个元素不断与后k位交换

  4. 基于以下事实：当数组元素向右移动n次后，尾部会有k mod n个元素移动至头部，其余元素则向后移动k mod n个位置。通过观察，可以发现旋转结果可以通过三次反转实现，只需要自己写一个翻转方法即可

     ```java
     nums = "----->-->"; k =3
     result = "-->----->";
     
     reverse "----->-->" we can get "<--<-----"
     reverse "<--" we can get "--><-----"
     reverse "<-----" we can get "-->----->"
     this visualization help me figure it out :)
     ```

     

##### #283 移动零

> 双指针

- 思路
  1. 非零往前补，然后补零。统计了0的个数以确定需要移动多少位。但是过程中出现了溢出、连续为0的情况，没有处理好。且代码略复杂
  2. 应该忽略0的存在。左指针总是指向非零部分的结尾处，右指针不断检查下一位是否为零，需遍历整个数组。指针可以藏在循环里（这里右指针是以foreach形式展现的）



##### #278 第一个错误的版本

> 双指针-二分查找

- 思路
  1. 因为答案在某一点处，且该点前后内容有区分度，所以使用二分查找。



##### #344 反转字符串

> 双指针

- 思路：双指针往中间靠拢



##### #542

> bfs

- 思路
  1. 先找到所有的0并添加到队列中，然后开始遍历



##### #557 反转字符串中的单词

> 双指针

- 思路
  1. 先将字符串转为char[]，右指针不断右移寻找空格或字符串结束处，左指针则指向空格右边的字符，这样界定了一个单词，使用双指针靠拢进行反转。最后将char[]导入到StringBuffer中再转String
  2. Java不能直接操作String类型，所以一定需要开辟新空间，所以可以每找到一个单词就把他的倒序放入字符串中



##### #567 字符串的排列

> 双指针-滑动窗口

- 思路
  1. 双指针，且以右指针为终点，向前s1的字符长度作为起点（这样规避了s1比s2长的情况），使用双数组判断是否字符数量相等。若发现s1中没有的字符，则直接以此位置下一位作起点；发现s1中出现的字符但是使用数量超过了，则右指针右移一位（因为无法判断从何处开始。写代码过程中忽视了这里）。运行结果性能排名不佳
  2. 优化1：实际上整个窗口有时只是右移了一个单位，但却对整个窗口内的字符串进行了重新统计。此外数组的对比可以使用`Arrays.equals()`。优化后耗时提升了近50ms
  3. 优化2：实际上也不需要对整个数组进行比较。使用了diff变量进行统计两者值不同的个数，并在修改前后查看所添加字符能否使得diff削减。同时为了简化逻辑，可以只使用一个数组：两个数组字母的差值数（一个减，一个加）
  4. 不是滑动窗口的方法：同样使用了一个差分cnt数组，但关注点只有cnt值是否为正（是否多了），以及左右指针拉开的长度是否等于s1的长度（是否没少）。字符串2不断右移并判断新加入的字符是否使得cnt值大于0，若有，则不断右移左指针直到这种情况消失。然后判断左右指针长度差是否相等。和上述方法比较，关注点少了，处理也更清晰，性能也得到了提升



##### #617 合并二叉树

> 树

- 思路
  1. 想着是用dfs，但是递归写得2不好，着重点在当前结点的左右结点，因为没有处理好非空的关系，所以失败了
  2. 答案的dfs着重点在当前结点上，每次进入函数先判断该节点是否为空，使得处理方便



##### #695 岛屿的最大面积

> 图

- 思路
  1. 不断按顺序遍历二维数组，若发现一个未遍历过的岛则开始测量其面积，并将遍历过的大陆标为2，使用的是广度优先。最终通过不断比较得到最大岛的面积。注意不要看错题，虽然岛的数量和最大岛面积数值一样
- 感想
  - 深度优先和广度优先算法的区别就在于广度优先核心是队列，而深度优先核心是栈（递归可以用栈（Deque）代替）



##### #704 二分查找

> 双指针-二分查找

- 思路

  1. 因为数组元素有序，所以使用二分查找

- 二分查找算法:star:

  ```java
  public int search(int[] nums, int target){
  	int mid, l = 0, r = nums.length-1;
  	while(l<=r){
  		mid = (r+l)/2;
      // mid = l + (r-l)/2
      // 等效写法，但是能够避免溢出
      if(target<nums[mid]) r = mid - 1;
      else if(target>nums[mid]) l = mid + 1;
      else return mid;
  	}
  	return -1;
  }
  ```

  - 注意观察如何避免数组只有一个元素时进入不了循环
  - 注意左指针和右指针和mid指针的区别，这应该和答案区间有关，也是为了让指针最后能够相等，以及退出循环



##### #733 图像渲染

> 图

- 思路

  1. 广度优先：不断把未更换前颜色的区域加入到队列中，通过换成最新颜色、出队表示遍历过的区域，当出现更换前颜色与更换后颜色相同的情况时应该直接返回原数组，否则会出现死循环
  2. 深度优先：

- 提示

  1. 数组是可以加到队列中的

     ```java
     Queue<int[]> queue = new LinkedList<int[]>();
     queue.offer(new int[]{sr,sc});
     ```

  2. 不用直接为上下左右四个方向各写1次判断，可以添加到数组，然后通过循环操作

     ```java
     int[] dx = {1, 0, 0, -1};
     int[] dy = {0, 1, -1, 0};
     // 上下左右
     ```

     

##### #876 链表的中间结点

> 双指针

- 思路
  1. 快慢指针



##### #977 有序数组的平方

> 双指针

- 思路
  1. 因为数组有序，所以用双指针。先找到正负交界处，然后双指针不断往外扩散，直到填满整个数组为止
  2. 同样是使用双指针，但是可以把指针指向数组两端，不需要判断正负，只需要不断比较指针处平方结果，并按照从大到小的顺序放入数组，直到指针相遇



##### #994 腐烂的橘子

> bfs

- 思路
  1. 直接套模板



##### #5863 统计特殊四元组

> 数组

- 思路
  1. 通过循环初始条件使得四个元素皆不相同，然后通过四重循环条件得到题解



##### #5864 游戏中弱角色的数量

>数组

- 思路
  1. 应该控制顺序，先比较第一个数并排好序，再比较第二个数是否比排序在其前最小一个数还要小。二维数组的排序可以通过`Arrays.sort(T[] a, Comparator<? super T> c)`重写其`compare()`方法，再自定义比较



##### #5868 可互换矩形的数组

- 思路

  1. 忽略了返回类型是long类型，也缺乏对数字最大值的概念，所以出了错

- 提示

  1. 哈希表HashMap同样可以遍历。除此之外，foreach变量可以把各种类型用var指代

     ```java
     for (var x:map.values()) { // long x:
                 cnt += x*(x-1)/2;
     }
     ```

  2. 哈希表的修改、添加可以简写（有则加一，无则加入）

     ```java
     for(var data:rectangles){
                 double convert = (double)data[0]/data[1];
                 map.put(convert, map.getOrDefault(convert, 0L)+1L);
           }
     ```

     









